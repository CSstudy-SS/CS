### 공부 주제 (복습 + 추가)

- HTTP / HTTPS
- TLS / SSL handshake
- 로드밸런싱
- Blocking, NonBlocking & Synchronous, Asynchronous
- Blocking & Non-Blocking IO

## 질문


- HTTP란 무엇인가요?
    <details>

    - 하이퍼 텍스트 전송 규약
    - 웹 상에서 주고받는 데이터 전송에 대한 여러 규칙
    - 서버와 클라이언트 구조에서 사용되는 프로토콜
    - 서버 - 클라이언트 프로토콜 중 하나이므로, http 역시 요청과 응답을 주고받는 매커니즘을 기본으로 한다.
    </details>

- http의 프로토콜은 OSI 7계층 중에서 몇번째 계층의 프로토콜인지?
    <details>

    - 애플리케이션 계층
    - 왜? 웹 브라우저와 웹 서버 간의 통신 방법
    </details>

- http통신과 Socket 통신의 차이점에 대해 설명해주세요
    <details>

    - HTTP 통신
        - 클라이언트의 요청이 있을 때만 서버가 응답
        - JSON, HTML, Image 등 다양한 데이터를 주고 받을 수 있음
        - 서버가 응답한 후 연결을 바로 종료하는 단방향 통신이지만 Keep Alive 옵션을 주어 일정 시간동안 커넥션을 유지할 수 있다.
        - 실시간 연결이 아닌 데이터 전달이 필요한 경우에만 요청을 보내는 상황에 유리
    - Socket 통신
        - 클라이언트와 서버가 특정 포트를 통해 양방향 통신을 하는 방식
        - 데이터 전달 후 연결이 끊어지는 것이 아니라 계속해서 연결을 유지 → HTTP에 비해 더 많은 리소스 소모
        - 클라이언트와 서버가 실시간으로 계속하여 데이터를 주고받아야하는 경우에 유리
        - 실시간 동영상 스트리밍이나 온라인 게임 등에 사용
    </details>

- http의 특징에 대해 말해주세요
    <details>

    - Stateless
        - 서버가 클라이언트의 정보를 관리하지 않는다.
        - 따라서 서버의 부하가 덜하고, 정보 전달이 빠를 수 있다

    - 비연결 지향(connectionless)
        - 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response를 보내면 바로 연결을 끊는다.
    </details>

- 그렇다면 Stateful과 Stateless의 차이에 대해 말해주고, 각각의 문제점에 대해 말해주세요
    <details>

    - 상태 유지 (Stateful)
        - 클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존함을 의미한다.
        - 클라이언트 - 서버 간의 데이터 송수신을 하며, 단계별 과정을 진행하는데, 서버에서 클라이언트가 이전 단계에서 제공한 값을 저장하고 다음 단계에서도 저장한 상태이다.
        - 문제점
            - 해당 서버가 멈추거나 여러 이유로 해당 서버가 못쓰게 되어, 다른 서버를 사용해야 할 때 문제가 발생한다.
                - 새로운 서버는 이전 서버에서 가지고 있던 상태값들을 가지고 있지 않기 때문
    - Stateless
        - 클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존하지 않음을 의미한다.
        - 서버는 단순히 요청이 오면 응답을 보내는 역할만 수행
        - 문제점
            - 클라이언트의 요청에 **상대적으로 Stateful 보다 더 많은 데이터**가 소모된다.
            - 매번 요청할 때마다 자신의 부가 정보를 줘야 한다.
    </details>

- Stateful, Stateless 한 대표적인 프로토콜에 대해 말해주세요
    <details>

    - Stateful : TCP
    - Stateless : UDP, HTTP
    </details>

- HTTP의 무상태 특징으로 인해 생기는 '인증'에 대한 문제점을 어떻게 해결할 수 있을까?
    <details>

    - 쿠키 : 쿠키는 웹 브라우저가 보관하는 데이터다,웹 서버는 쿠키를 생성하여 웹 브라우저에 정보를 전송할 수 있고, 쿠키는 key-value 형태로 웹 브라우저의 쿠키 저장소에 저장된다. 서버로부터 쿠키를 전달 받은 웹 브라우저는 이후 웹 서버에 요청을 보낼 때 쿠키를 헤더에 실어서 함께 전송한다.
    
    - 세션 : 쿠키와 다른 점은, 쿠키는 각 브라우저의 별 도 쿠키 저장소에 저장되는 반면 세션은 서버에 저장이 된다. 웹 브라우저는 각각 별도의 세션을 갖는다. 각 세션을 구분하기 위해 고유 ID를 할당하고, 웹 서버는 각 브라우저에게 세션 ID를 전송한다. 웹 브라우저는 웹 서버에 연결 시 매번 세션 ID를 보내서 웹 서버가 어떤 세션을 사용할 지 알 수 있도록 한다. 이때, 웹 서버와 웹 브라우저가 세션 ID를 주고 받기 위해 사용하는 것이 쿠키다. 세션 ID를 쿠키에 넣는다고 생각하면 된다.
    
    - 토큰 : 토큰 기반 인증의 방법으로 많은 웹 서버들은 JWT (JSON Web Token)을 사용한다. 토큰 기반 인증 방식은 유저의 정보가 서버에 저장되지 않는 무상태라는 특징이 있다
    </details>

- Connectionless의 특징에 대해 말해주세요
    <details>

    - 요청과 응답을 받으면 바로 연결을 유지하지 않음 → 최소한의 자원을 유지
    - HTTP는 기본이 연결을 유지하지 않는 모델
    - 일반적으로 초 단위의 이하의 빠른 속도로 응답
    - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
    - 서버 자원을 매우 효율적으로 사용할 수 있음
    </details>

- Connectionless이 가지는 한계에 대해 말해주세요
    <details>

    - TCP / IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가
    - 웹 브라우저로 사이트를 요청하면, html 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함께 다운로드
    - 지금은 http 지속 연결(Persistent Connections)로 문제 해결
    - HTTP/2, HTTP/3에서 더 많은 최적화
    </details>

- HTTP 지속 연결과 비지속 연결에 대해 설명해주세요
    <details>

    - 비지속 연결 : 자원 하나 하나 요청건에 대해서 연결을 시도(3 way handshake)하여 요청함.
        - 연결시도 횟수가 많아 비효율적.
    - 지속 연결 : 자원 하나를 요청했을때 이와 묶여있는 모든 자원을 요청하기 위해 연결을 유지한 상태.
        - HTTP 1.0 기준으로 클라이언트에서 지속연결을 원할 때 Keep-Alive를 헤더에 담아서 요청
        - 연결시도 횟수가 줄어들어 효율적.
    </details>

- 그렇다면 Stateless와 Connectionless의 차이는 무엇인가요?
    <details>
    Stateless
    필요한 상태에 대한 정보를 클라이언트가 가지고 오기 때문에, 클라이언트의 요청에 어느 서버가 응답해도 상관없음. → 클라이언트의 요청이 대폭 증가하면 서버를 증설해 해결할 수 있음

    Connections
    클라이언트가 서버에 요청을 하고, 응답을 받으면 바로 TCP/IP 연결을 끊어 연결을 유지하지 않음으로써, 서버의 자원을 효율적으로 관리하고, 수 많은 클라이언트의 요청에 대응할 수 있게 함

    무상태성은 클라이언트와 서버 간의 상태 정보를 들고있지 않아, 클라이언트가 상태 정보를 일일히 http에 실어 요청해야 되는 것
    비연결성은 클라이언트와 서버 간에 네트워크 연결이 끊어져 단절된다.
    </details>

- HTTP 메서드의 특성 3가지에 대해 말해주세요
    <details>
    - 안전성
        - 호출해도 리소스 변경이 일어나지 않는 속성
        - 오직 리소스 변경 가능성 → 외적인 요소 포함 X
        - GET,HEAD를 안전한 메소드
    - 멱등성
    - 캐시가능
    </details>

- HTTP의 문제점에 대해 말해주세요
    <details>

    1. http는 평문 통신이기 때문에 도청이 가능하다
    2. 통신 상대를 확인하지 않기 때문에 위장이 가능하다
    3. 완전성을 증명할 수 없기 때문에 변조가 가능하다

    **→ 암호화되지 않은 프로토콜에도 공통되는 문제점**

    - TCP/ IP 구조의 통신은 경로 상에서 엿보기 각능 → 패킷 수집만으로 도청 가능
    </details>


- TLS 와 SSL의 차이점은?
    <details>
    보안: TLS는 더 강력한 암호화 알고리즘, 더 나은 인증 메커니즘 및 향상된 키 교환 프로토콜을 가지고 있습니다.

    프로토콜 버전: SSL은 2015년 이후 더 이상 안전하지 않으며 TLS는 계속 개발 및 개선되고 있습니다. 

    TLS는 TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3을 포함한 여러 버전이 있으며, 각 버전은 이전 버전보다 더 나은 보안을 제공한다.

    등 성능, 호환성 모든 부분에서 ssl보다 좋다.
    </details>

- L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.
    <details>

    - L4
        - 전송계층
        - TCP/UDP 포트 정보를 바탕으로한다.
        - 데이터 안을 들여다보지 않고, 패킷 레벨에서만 로드를 분산하기 때문에 속도가 빠르고 효율이 높다.
        - L7로드밸런서보다 가격이 저렴하다.
        - 패킷의 내용을 살펴볼 수 없기 때문에 섬세한 라우팅이 불가능하다.
        - 사용자의 IP가 수시로 바뀌는 경우라면 연속적인 서비스를 제공하기 어려움
    - L7
        - 응용 계층
        - TCP/UDP 정보는 물론 HTTP의 URI, FTP의 파일명, 쿠키 정보 등을 바탕으로 함
        - 상위 계층에서 로드를 분산하기 때문에 훨씬 더 섬세한 라우팅이 가능함
        - 캐싱 기능을 제공함
        - 비정상적인 트래픽을 사전에 필터링할 수 있어, 서비스 안정성이 높음
        - 패킷의 내용을 복호화해야하기에 더 높은 비용을 지불해야함
        - 클라이언트가 로드밸런서와 인증서를 공유해야하기 때문에 공격자가 로드밸런서를 통해 클라이언트에 데이터에 접근할 보안 상의 위험성 존재
    </details>

- 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.
    <details>
    DNS 기반 로드밸런싱은 **동일한 도메인 이름을 가진 여러 서버 중에서 클라이언트에게 가장 적합한 서버를 선택하는 방식**입니다. 이 방식은 로드밸런서 장치를 사용하지 않아도 적용할 수 있습니다.

    DNS 기반 로드밸런싱은 **DNS 서버에 여러 IP 주소를 등록**하여, **각각의 IP 주소가 다른 서버를 가리키도록 설정**합니다. 그리고 클라이언트가 해당 도메인 이름을 조회하면, **DNS 서버가 가리키는 IP 주소 중에서 랜덤하게 하나를 반환**합니다. 이렇게 반환된 IP 주소를 이용하여 클라이언트는 서버에 접속합니다.

    이 방식의 가장 큰 장점은 구성이 매우 간단하다는 것입니다. 하지만 **이 방식은 클라이언트와 서버 간의 연결을 관리하지 않기 때문에, 모든 서버가 동일한 성능을 가지고 있지 않을 경우에는 불균형한 로드밸런싱이 발생**할 수 있습니다. 또한 **DNS 서버가 일시적으로 다운되거나 DNS 캐시 문제로 인해 오래된 IP 주소를 반환하는 경우**도 발생할 수 있습니다.

    이러한 한계를 극복하기 위해, **TTL 값을 작게 설정하여 DNS 서버의 캐시를 자주 갱신**하거나, DNS 서버를 여러 개 사용하여 장애 발생 시에 대처할 수 있는 환경을 구성하는 등의 방법을 사용할 수 있습니다.
    </details>

- 로드밸런서가 장애를 대비하는 방법에 대해 설명해주세요
    <details>
    로드 밸런서는 갑작스러운 장애에 대비해 이중화를 기본으로 구성한다. 이중화된 로드 밸런서들은 서로의 상태를 확인하며 장애가 발생하면 정상적으로 작동하는 로드 밸런서로 교체된다.
    </details>

- blocking과 non-blocking의 차이점은 무엇인가요?
    <details>
    blocking은 작업이 끝날 때까지 다른 작업을 수행하지 않고 기다리는 것이고, non-blocking은 작업이 진행되는 동안 다른 작업을 수행할 수 있는 것
    </details>

-  동기, 비동기 방식의 차이점은?
    <details>
    동기는 요청과 응답이 한 번에 처리되는 방식이다. 요청한 작업이 완료될 때까지 다음 작업을 처리하지 않는다.

    반면에 비동기는 요청한 작업의 완료 여부와는 관계없이 다음 작업을 처리하고, 요청한 작업이 완료되면, 이벤트나 콜백을 통해 결과값을 받아온다.
    </details>

### 정리 링크

* 세정 : [20주차 질문 준비](https://setorylog.oopy.io/6f091e24-61ff-4437-8b48-95f5174628d0)

