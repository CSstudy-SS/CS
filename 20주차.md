### 공부 주제 (복습 + 추가)

- HTTP / HTTPS
- TLS / SSL handshake
- 로드밸런싱
- Blocking, NonBlocking & Synchronous, Asynchronous
- Blocking & Non-Blocking IO

## 질문


- HTTP란 무엇인가요?
    <details>

    - 하이퍼 텍스트 전송 규약
    - 웹 상에서 주고받는 데이터 전송에 대한 여러 규칙
    - 서버와 클라이언트 구조에서 사용되는 프로토콜
    - 서버 - 클라이언트 프로토콜 중 하나이므로, http 역시 요청과 응답을 주고받는 매커니즘을 기본으로 한다.
    </details>

- http의 프로토콜은 OSI 7계층 중에서 몇번째 계층의 프로토콜인지?
    <details>

    - 애플리케이션 계층
    - 왜? 웹 브라우저와 웹 서버 간의 통신 방법
    </details>

- http통신과 Socket 통신의 차이점에 대해 설명해주세요
    <details>

    - HTTP 통신
        - 클라이언트의 요청이 있을 때만 서버가 응답
        - JSON, HTML, Image 등 다양한 데이터를 주고 받을 수 있음
        - 서버가 응답한 후 연결을 바로 종료하는 단방향 통신이지만 Keep Alive 옵션을 주어 일정 시간동안 커넥션을 유지할 수 있다.
        - 실시간 연결이 아닌 데이터 전달이 필요한 경우에만 요청을 보내는 상황에 유리
    - Socket 통신
        - 클라이언트와 서버가 특정 포트를 통해 양방향 통신을 하는 방식
        - 데이터 전달 후 연결이 끊어지는 것이 아니라 계속해서 연결을 유지 → HTTP에 비해 더 많은 리소스 소모
        - 클라이언트와 서버가 실시간으로 계속하여 데이터를 주고받아야하는 경우에 유리
        - 실시간 동영상 스트리밍이나 온라인 게임 등에 사용
    </details>

- http의 특징에 대해 말해주세요
    <details>

    - Stateless
        - 서버가 클라이언트의 정보를 관리하지 않는다.
        - 따라서 서버의 부하가 덜하고, 정보 전달이 빠를 수 있다

    - 비연결 지향(connectionless)
        - 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response를 보내면 바로 연결을 끊는다.
    </details>

- 그렇다면 Stateful과 Stateless의 차이에 대해 말해주고, 각각의 문제점에 대해 말해주세요
    <details>

    - 상태 유지 (Stateful)
        - 클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존함을 의미한다.
        - 클라이언트 - 서버 간의 데이터 송수신을 하며, 단계별 과정을 진행하는데, 서버에서 클라이언트가 이전 단계에서 제공한 값을 저장하고 다음 단계에서도 저장한 상태이다.
        - 문제점
            - 해당 서버가 멈추거나 여러 이유로 해당 서버가 못쓰게 되어, 다른 서버를 사용해야 할 때 문제가 발생한다.
                - 새로운 서버는 이전 서버에서 가지고 있던 상태값들을 가지고 있지 않기 때문
    - Stateless
        - 클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존하지 않음을 의미한다.
        - 서버는 단순히 요청이 오면 응답을 보내는 역할만 수행
        - 문제점
            - 클라이언트의 요청에 **상대적으로 Stateful 보다 더 많은 데이터**가 소모된다.
            - 매번 요청할 때마다 자신의 부가 정보를 줘야 한다.
    </details>

- Stateful, Stateless 한 대표적인 프로토콜에 대해 말해주세요
    <details>

    - Stateful : TCP
    - Stateless : UDP, HTTP
    </details>

- HTTP의 무상태 특징으로 인해 생기는 '인증'에 대한 문제점을 어떻게 해결할 수 있을까?
    <details>

    - 쿠키 : 쿠키는 웹 브라우저가 보관하는 데이터다,웹 서버는 쿠키를 생성하여 웹 브라우저에 정보를 전송할 수 있고, 쿠키는 key-value 형태로 웹 브라우저의 쿠키 저장소에 저장된다. 서버로부터 쿠키를 전달 받은 웹 브라우저는 이후 웹 서버에 요청을 보낼 때 쿠키를 헤더에 실어서 함께 전송한다.
    
    - 세션 : 쿠키와 다른 점은, 쿠키는 각 브라우저의 별 도 쿠키 저장소에 저장되는 반면 세션은 서버에 저장이 된다. 웹 브라우저는 각각 별도의 세션을 갖는다. 각 세션을 구분하기 위해 고유 ID를 할당하고, 웹 서버는 각 브라우저에게 세션 ID를 전송한다. 웹 브라우저는 웹 서버에 연결 시 매번 세션 ID를 보내서 웹 서버가 어떤 세션을 사용할 지 알 수 있도록 한다. 이때, 웹 서버와 웹 브라우저가 세션 ID를 주고 받기 위해 사용하는 것이 쿠키다. 세션 ID를 쿠키에 넣는다고 생각하면 된다.
    
    - 토큰 : 토큰 기반 인증의 방법으로 많은 웹 서버들은 JWT (JSON Web Token)을 사용한다. 토큰 기반 인증 방식은 유저의 정보가 서버에 저장되지 않는 무상태라는 특징이 있다
    </details>

- Connectionless의 특징에 대해 말해주세요
    <details>

    - 요청과 응답을 받으면 바로 연결을 유지하지 않음 → 최소한의 자원을 유지
    - HTTP는 기본이 연결을 유지하지 않는 모델
    - 일반적으로 초 단위의 이하의 빠른 속도로 응답
    - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
    - 서버 자원을 매우 효율적으로 사용할 수 있음
    </details>

- Connectionless이 가지는 한계에 대해 말해주세요
    <details>

    - TCP / IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가
    - 웹 브라우저로 사이트를 요청하면, html 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함께 다운로드
    - 지금은 http 지속 연결(Persistent Connections)로 문제 해결
    - HTTP/2, HTTP/3에서 더 많은 최적화
    </details>

- HTTP 지속 연결과 비지속 연결에 대해 설명해주세요
    <details>

    - 비지속 연결 : 자원 하나 하나 요청건에 대해서 연결을 시도(3 way handshake)하여 요청함.
        - 연결시도 횟수가 많아 비효율적.
    - 지속 연결 : 자원 하나를 요청했을때 이와 묶여있는 모든 자원을 요청하기 위해 연결을 유지한 상태.
        - HTTP 1.0 기준으로 클라이언트에서 지속연결을 원할 때 Keep-Alive를 헤더에 담아서 요청
        - 연결시도 횟수가 줄어들어 효율적.
    </details>

- 그렇다면 Stateless와 Connectionless의 차이는 무엇인가요?
    <details>
    Stateless
    필요한 상태에 대한 정보를 클라이언트가 가지고 오기 때문에, 클라이언트의 요청에 어느 서버가 응답해도 상관없음. → 클라이언트의 요청이 대폭 증가하면 서버를 증설해 해결할 수 있음

    Connections
    클라이언트가 서버에 요청을 하고, 응답을 받으면 바로 TCP/IP 연결을 끊어 연결을 유지하지 않음으로써, 서버의 자원을 효율적으로 관리하고, 수 많은 클라이언트의 요청에 대응할 수 있게 함

    무상태성은 클라이언트와 서버 간의 상태 정보를 들고있지 않아, 클라이언트가 상태 정보를 일일히 http에 실어 요청해야 되는 것
    비연결성은 클라이언트와 서버 간에 네트워크 연결이 끊어져 단절된다.
    </details>

- HTTP 메서드의 특성 3가지에 대해 말해주세요
    <details>
    - 안전성
        - 호출해도 리소스 변경이 일어나지 않는 속성
        - 오직 리소스 변경 가능성 → 외적인 요소 포함 X
        - GET,HEAD를 안전한 메소드
    - 멱등성
    - 캐시가능
    </details>

- HTTP의 문제점에 대해 말해주세요
    <details>

    1. http는 평문 통신이기 때문에 도청이 가능하다
    2. 통신 상대를 확인하지 않기 때문에 위장이 가능하다
    3. 완전성을 증명할 수 없기 때문에 변조가 가능하다

    **→ 암호화되지 않은 프로토콜에도 공통되는 문제점**

    - TCP/ IP 구조의 통신은 경로 상에서 엿보기 각능 → 패킷 수집만으로 도청 가능
    </details>


- TLS 와 SSL의 차이점은?
    <details>
    보안: TLS는 더 강력한 암호화 알고리즘, 더 나은 인증 메커니즘 및 향상된 키 교환 프로토콜을 가지고 있습니다.

    프로토콜 버전: SSL은 2015년 이후 더 이상 안전하지 않으며 TLS는 계속 개발 및 개선되고 있습니다. 

    TLS는 TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3을 포함한 여러 버전이 있으며, 각 버전은 이전 버전보다 더 나은 보안을 제공한다.

    등 성능, 호환성 모든 부분에서 ssl보다 좋다.
    </details>

- L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.
    <details>

    - L4
        - 전송계층
        - TCP/UDP 포트 정보를 바탕으로한다.
        - 데이터 안을 들여다보지 않고, 패킷 레벨에서만 로드를 분산하기 때문에 속도가 빠르고 효율이 높다.
        - L7로드밸런서보다 가격이 저렴하다.
        - 패킷의 내용을 살펴볼 수 없기 때문에 섬세한 라우팅이 불가능하다.
        - 사용자의 IP가 수시로 바뀌는 경우라면 연속적인 서비스를 제공하기 어려움
    - L7
        - 응용 계층
        - TCP/UDP 정보는 물론 HTTP의 URI, FTP의 파일명, 쿠키 정보 등을 바탕으로 함
        - 상위 계층에서 로드를 분산하기 때문에 훨씬 더 섬세한 라우팅이 가능함
        - 캐싱 기능을 제공함
        - 비정상적인 트래픽을 사전에 필터링할 수 있어, 서비스 안정성이 높음
        - 패킷의 내용을 복호화해야하기에 더 높은 비용을 지불해야함
        - 클라이언트가 로드밸런서와 인증서를 공유해야하기 때문에 공격자가 로드밸런서를 통해 클라이언트에 데이터에 접근할 보안 상의 위험성 존재
    </details>

- 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.
    <details>
    DNS 기반 로드밸런싱은 **동일한 도메인 이름을 가진 여러 서버 중에서 클라이언트에게 가장 적합한 서버를 선택하는 방식**입니다. 이 방식은 로드밸런서 장치를 사용하지 않아도 적용할 수 있습니다.

    DNS 기반 로드밸런싱은 **DNS 서버에 여러 IP 주소를 등록**하여, **각각의 IP 주소가 다른 서버를 가리키도록 설정**합니다. 그리고 클라이언트가 해당 도메인 이름을 조회하면, **DNS 서버가 가리키는 IP 주소 중에서 랜덤하게 하나를 반환**합니다. 이렇게 반환된 IP 주소를 이용하여 클라이언트는 서버에 접속합니다.

    이 방식의 가장 큰 장점은 구성이 매우 간단하다는 것입니다. 하지만 **이 방식은 클라이언트와 서버 간의 연결을 관리하지 않기 때문에, 모든 서버가 동일한 성능을 가지고 있지 않을 경우에는 불균형한 로드밸런싱이 발생**할 수 있습니다. 또한 **DNS 서버가 일시적으로 다운되거나 DNS 캐시 문제로 인해 오래된 IP 주소를 반환하는 경우**도 발생할 수 있습니다.

    이러한 한계를 극복하기 위해, **TTL 값을 작게 설정하여 DNS 서버의 캐시를 자주 갱신**하거나, DNS 서버를 여러 개 사용하여 장애 발생 시에 대처할 수 있는 환경을 구성하는 등의 방법을 사용할 수 있습니다.
    </details>

- 로드밸런서가 장애를 대비하는 방법에 대해 설명해주세요
    <details>
    로드 밸런서는 갑작스러운 장애에 대비해 이중화를 기본으로 구성한다. 이중화된 로드 밸런서들은 서로의 상태를 확인하며 장애가 발생하면 정상적으로 작동하는 로드 밸런서로 교체된다.
    </details>

- blocking과 non-blocking의 차이점은 무엇인가요?
    <details>
    blocking은 작업이 끝날 때까지 다른 작업을 수행하지 않고 기다리는 것이고, non-blocking은 작업이 진행되는 동안 다른 작업을 수행할 수 있는 것
    </details>

-  동기, 비동기 방식의 차이점은?
    <details>
    동기는 요청과 응답이 한 번에 처리되는 방식이다. 요청한 작업이 완료될 때까지 다음 작업을 처리하지 않는다.

    반면에 비동기는 요청한 작업의 완료 여부와는 관계없이 다음 작업을 처리하고, 요청한 작업이 완료되면, 이벤트나 콜백을 통해 결과값을 받아온다.
    </details>
    
-  HTTP와 HTTPS의 차이점은?
    <details>
        - 인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약

        HTTPS는 텍스트를 암호화한다. (공개키 암호화 방식으로!)
    </details>
-  HTTP 응답코드에 대해 설명해 주세요.
    <details>
        HTTP의 응답 상태를 명시해주는 코드이다.
    </details>
-  401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?
    <details>
        HTTP(하이퍼텍스트 전송 프로토콜) **`401 Unauthorized`** 응답 상태 코드는 요청된 리소스에 대한 유효한 인증 자격 증명이 없기 때문에 클라이언트 요청이 완료되지 않았음을 나타냅니다.

        하이퍼텍스트 전송 프로토콜(HTTP)의 **`406 Not Acceptable`** 클라이언트 에러 응답 코드는 서버가 요청의 주도적인 [콘텐츠 협상](https://developer.mozilla.org/ko/docs/Web/HTTP/Content_negotiation) 헤더에 정의된 허용 가능한 값 목록과 일치하는 응답을 생성할 수 없으며, 서버가 기본 표현을 제공하지 않음을 나타냅니다.

        따라서, 401 Unauthorized는 인증 실패를 나타내고, 403 Forbidden은 인가 실패를 나타냅니다.

        - 그렇다면 인증과 인가의 차이점은??
    </details>
-  공개키와 대칭키에 대해 설명해 주세요.
    <details>
        대칭키 암호화는 하나의 키를 사용하여 암호화와 복호화를 동시에 수행하는 방식입니다. 즉, 암호화와 복호화에 동일한 비밀키를 사용하는 방식입니다

        공개키 암호화는 두 개의 키를 사용하는 방식입니다. 하나는 공개키(public key)이고 다른 하나는 개인키(private key)입니다. 공개키는 누구나 알 수 있으며, 개인키는 오직 소유자만이 알고 있습니다. 이러한 방식은 송신자가 수신자의 공개키를 이용하여 암호화를 수행하고, 수신자는 자신의 개인키를 이용하여 복호화를 수행하는 방식입니다.
    </details>
-  SSL과 TLS의 차이는 무엇인가요?
    <details>
        SSL은 과거에 사용 되었던 HTTPS의 인증방식이었으나 치명적인 보안결함이 발견되어 현재는 TLS로 인증방식을 바꾸게 되었다.

        가장 큰 차이점 중 하나는 암호화 방식입니다. SSL은 RC4를 사용하고, TLS는 RC4 대신 AES를 사용합니다. 또한, TLS는 SSL과 달리 더 강력한 암호화 기술을 제공합니다. SSL 3.0에서 발견된 POODLE 보안 결함 등의 문제도 TLS가 보완했습니다.

        또한, SSL과 TLS는 버전별로 호환되지 않습니다. 즉, SSL 3.0 클라이언트는 TLS 1.0 서버와 통신할 수 없습니다. TLS는 SSL의 호환성 문제와 보안 결함 등을 개선하고 보다 강력한 암호화 기술을 제공하면서 SSL을 대체하였습니다. 현재 대부분의 웹 사이트에서는 TLS를 사용하여 데이터를 보호하고 있습니다.
    </details>
-  왜 HTTP는 TCP를 사용하나요?
    <details>
        HTTP는 기본적으로 Statess하기 때문에 어느 클라이언트가 어떤 순서로 데이터를 보냈는지 저장하지 않는다. 그러므로 데이터의 순서와 신뢰성을 보장해야 하기 때문에 TCP를 사용한다.

        따라서, HTTP는 TCP를 사용하여 신뢰적이고 순서가 보장되며, 연결 지향성과 네트워크 혼잡 제어를 위한 기능을 활용합니다.
    </details>
- StateLess 하다는 것은? 무슨 의미인가요? Connectionless와의 무슨 차이점이있나요
        <details>
            Stateless는 서버나 클라이언트가 이전 상태를 유지하지 않는 것을 의미합니다. 각각의 요청이 독립적으로 처리되며, 이전 요청과 관련된 정보를 저장하지 않습니다. 이는 서버의 부담을 줄이고 확장성을 높이는 장점이 있습니다. Stateless 프로토콜의 대표적인 예로는 HTTP가 있습니다.

            Connectionless는 데이터 패킷을 보내기 전에 먼저 연결을 설정하는 과정이 없이, 각각의 패킷이 독립적으로 처리되는 것을 의미합니다. 각각의 패킷은 독립적으로 처리되기 때문에 전송 순서가 바뀌거나 중복되어 전송될 수도 있습니다. Connectionless 프로토콜의 대표적인 예로는 UDP가 있습니다. UDP는 일부 데이터 패킷이 손실되더라도, 재전송을 요구하지 않고 그냥 무시합니다. 이러한 특성 때문에 UDP는 실시간 스트리밍 등에서 사용됩니다.
        </details>
-  그렇다면, 왜 HTTP/3 에서는 UDP(QUIC) 를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
    <details>
        UDP는 신뢰성을 보장 못하는 것이 아니라 안한것이라고 할 수 있다. 어플리케이션 단에서 신뢰성을 추가할 수 있기 때문에 기존의 UDP통신에서 신뢰성을 추가하였다.
    </details>
-  로드 벨런서가 무엇인가요?
    <details>
        로드밸런서(load balancer)는 여러 대의 서버에게 부하를 분산시켜주는 기능을 하는 네트워크 장비입니다. 여러 대의 서버를 가지고 있는 경우, 로드밸런서를 통해 부하를 분산시킴으로써 서버의 안정성을 향상시킬 수 있습니다.
    </details>
-  L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.
    <details>
        L4 로드밸런서는 OSI 모델의 전송 계층에서 동작하며, IP 주소와 포트 번호를 기반으로 패킷을 로드밸런싱합니다. 이 방법은 TCP 및 UDP와 같은 로우레벨 프로토콜을 사용하는 애플리케이션에 적합합니다. L4 로드밸런서는 패킷을 전송할 서버를 선택하는 데 IP 주소와 포트 번호를 사용하므로 패킷의 내용을 고려하지 않습니다.

        반면 L7 로드밸런서는 OSI 모델의 애플리케이션 계층에서 동작합니다. L7 로드밸런서는 HTTP 헤더, 쿠키, 세션 ID 등과 같은 패킷의 내용을 기반으로 패킷을 로드밸런싱합니다. 이를 통해 애플리케이션 계층의 정보를 활용해 특정 서버로 연결할 수 있으며, 특정 사용자나 브라우저를 고유하게 식별할 수 있습니다. L7 로드밸런서는 SSL 인증서의 해석, 웹 애플리케이션 방화벽 기능 등 고급 기능을 제공할 수 있습니다.
    </details>
-  로드밸런서 알고리즘에 대해 설명해 주세요.
    <details>
        - 라운드 로빈(Round Robin) : CPU 스케줄링의 라운드 로빈 방식 활용
        - Least Connections : 연결 개수가 가장 적은 서버 선택 (트래픽으로 인해 세션이 길어지는 경우 권장)
        - Source : 사용자 IP를 해싱하여 분배 (특정 사용자가 항상 같은 서버로 연결되는 것 보장)
    </details>
    
-  DNS 로드 벨런싱에 대해 설명해주세요
    <details>
        DNS를 이용한 로드밸런싱 방법은 DNS Round Robin 방식입니다. 이 방식은 DNS 서버에서 도메인 이름에 대한 여러 개의 IP 주소를 반환하도록 설정하여, 클라이언트에서 도메인 이름을 DNS 서버에 쿼리하면 여러 개의 IP 주소가 반환되고, 클라이언트는 이 중 하나의 IP 주소를 선택하여 접속합니다.

        이 방식은 DNS 서버에서 여러 개의 IP 주소를 반환하는 방법으로 간단하지만, 모든 클라이언트가 균등하게 분산되지 않을 수 있으며, 각 서버의 상태를 고려하지 않습니다. 또한 DNS 캐싱이나 TTL (Time To Live) 등의 설정에 따라 트래픽이 특정 서버로 몰리는 경우가 발생할 수 있습니다. 따라서 실시간 트래픽 분산에는 한계가 있으며, 대규모 서비스에서는 로드밸런서를 사용하는 것이 일반적입니다.
    </details>
-  **Blocking/Non-blocking 의 차이점은?**
    <details>
        블럭/논블럭은 간단히 말해서 `호출된 함수`가 `호출한 함수`에게 제어권을 건네주는 유무의 차이라고 볼 수 있다.

        함수 A, B가 있고, A 안에서 B를 호출했다고 가정해보자. 이때 호출한 함수는 A고, 호출된 함수는 B가 된다. 현재 B가 호출되면서 B는 자신의 일을 진행해야 한다. (제어권이 B에게 주어진 상황)
    </details>
-  **Synchronous/Asynchronous의 차이점은?**
    <details>
        동기/비동기는 일을 수행 중인 `동시성`에 주목하자

        아까처럼 함수 A와 B라고 똑같이 생각했을 때, B의 수행 결과나 종료 상태를 A가 신경쓰고 있는 유무의 차이라고 생각하면 된다.
    </details>
-  함수 A, B, C가 순차적으로 실행되는 구조일 때 Sync/Blocking 과 Async/NonBlocking의 실행 흐름을 설명해주세요, 단 본 함수에선 함수 A가 끝나면 결과값을 바로 출력하고 B,C도 동일하게 출력합니다.
    <details>
        ***Sync/Blocking*** 

        프로그램을 실행하면서 A함수를 실행할땐 본 프로그램을 더 이상 실행하지 않으며 A함수를 실행하고 반환값을 출력하고 B, C함수도 동일하게 수행

        ***Async/NonBlocking***

        프로그램을 실행하며 A함수를 실행하고 즉시 프로그램으로 돌아와서 이어서 실행 return한 아무 값이 없는 undefined를 출력 이후에도 B, C함수를 실행한 후 즉시 프로그램으로 돌아온 후 A함수가 실행이 마치면 콜백함수를 통해 A함수의 결과값을 받고, 이후에 B,C함수의 콜백함수를 받는다.

        <확장 질문>

        - 그러면 node.js 는 싱글스레드인데 어떻게 async/nonblocking을 구현 할 수 있었을까요?
    </details>
### 정리 링크

* 세정 : [20주차 질문 준비](https://setorylog.oopy.io/6f091e24-61ff-4437-8b48-95f5174628d0)

