## 27주차

- 오토박싱 & 오토언박싱
- Thread 활용
- 고유락
- IPC
- CPU 스케줄링 

## 질문

### 오토박싱 & 오토 언박싱

- Wrapper Class란 무엇인가요?
    <details>

    - java에는 primitive type과 reference type이 있습니다.
    - primitive type의 경우 NULL 값을 담지 못하고, 제네릭 프로그래밍에 쓰지 못한다는 특징이 있다.
    - 이러한 경우와 같이 데이터를 객체로 표현해야 할 때 쓰이는 것이 Wrapper입니다.
    - 래퍼 클래스는 `java.lang` 패키지에 포함되고 있다.
    </details>

- 박싱과 언박싱의 정의에 대해 말해주세요
    <details>

    - 박싱 : 기본 타입의 데이터를 래퍼 클래스의 인스턴스로 변환하는 과정
    - 언박싱 : 래퍼 클래스의 인스턴스에 저장된 값을 다시 기본 타입의 데이터로 꺼내는 과정
    </details>

- 만약 Integer num1 으로 10을 선언하고 Integer num2로 5를 선언하였을 때 System.out.print(num1 > num2) 를 하면 무엇이 반환되는지?
    <details>

    - true 반환
    - 래퍼클래스의 비교 연산도 오토언박싱을 통해 가능
    </details>


- 만약 Integer num1 = new Integer(10); , Integer num2 = new Integer(10)  이렇게 선언이 된다면, num1 == num2 했을 때 결과가 어떻게 반환되는가?
    <details>

    - false 반환
    - 인스턴스에 저장된 값의 동등 여부의 판단은 비교 연산자인  == 을 사용해서는 안되며, `equals()` 메서드를 사용해야만한다.
    - 왜? → 래퍼클래스도 객체이므로, 동등연산자(==)를 사용하게 되면 두 인스턴스의 값을 비교하는 것이 아니라 두 인스턴스의 주소값을 반환한다.
    - 숫자를 비교하고 싶으면 `num1.equals(num2)` 연산을 사용해야한다.
    </details>


- 래퍼 클래스는 왜 필요한가요?
    <details>

    - 메서드에 전달된 arguments를 수정하기 위해
        - 기본형 변수 → 참조형 변수
        - 기본형 변수는 `값` 으로 전달되기 때문
    - `java.util` 패키지의 클래스들은 참조형 변수만을 다루기 때문
    - CF의 자료 구조인 `ArrayList` 와 `Vector` 는 참조형 변수만을 다루기 때문
    - 멀티스레딩에서 동기화를 지원하려면  “참조형변수”가 필요
    </details>


- 그렇다면, 오토박싱과 오토언박싱을 적극적으로 사용해도 되는가?
    <details>

    - 편의성을 위해 오토박싱과 언박싱이 제공되고 있지만, 내부적으로 추가 연산 작업이 거쳐지게 된다.
    - 따라서 오토 박싱 & 언박싱이 일어나지 않도록 동일 타입연산이 이루어지도록 구현하자!
    - 백만건 기준으로 성능 차이 5배 이상
    </details>


### java의 Thread

- Thread 란 무엇인가요?
    <details>

    - 독립적으로 수행 가능한 메인 프로세스 또는 메인 프로세스 외의 기타 프로세스의 기저
    - 하나의 프로세스 내에서 실행하는 병행 메서드 단위
    - 어플리케이션의 스레드가 모두 종료되면, 해당 어플리케이션이 종료된다.

    </details>

- 자바에서 스레드를 구현하는 방법에 대해 설명해주세요
    <details>

    - Runnable 인터페이스 구현
        - Thread클래스를 상속하는 것에 비해 어플리케이션의 유연성과 확장성 보장 가능
    - Thread 클래스 상속
        - 컴파일 타임 시점에 형식이 결정되어, 동적인 기능 변경이 불가하다.
    </details>


- 스레드를 실행 시킬 때 run() 으로 시작한다면 어떻게 되나요?
    <details>

    - 스레드는 main 메서드 위쪽 스택으로 쌓이게 되면서, “병행 처리”를 하지 못하게 된다.
    - 각 메서드가 종료되어야 다른 스레드가 실행된다.
    </details>

- 스레드에 우선순위를 두고 싶다면?
    <details>

    - 스레드의 우선 순위는 다중 cpu나, 멀티코어 환경에서는 무의미하다. 하지만
    - Thread의 `setPriority()` 메서드로 우선순위 지정 가능
    - 1 ~ 10까지 우선순위 지정 가능
        - 10 : 위기 관리
        - 7 ~ 9 :상호작용, 이벤트 관리
        - 4~6 : IO 관련 작업
        - 2~3 : 백그라운드 작업
        - 1 : 기타 작업
    </details>

- Thread의 동기화 방법에 대해 설명해주세요
    <details>

    - 임계 영역(critical section) : 공유 자원에 단 하나의 스레드만 접근하도록(하나의 프로세스에 속한 스레드만 가능)
    - 뮤텍스(mutex) : 공유 자원에 단 하나의 스레드만 접근하도록(서로 다른 프로세스에 속한 스레드도 가능)
    - 이벤트(event) : 특정한 사건 발생을 다른 스레드에게 알림
    - 세마포어(semaphore) : 한정된 개수의 자원을 여러 스레드가 사용하려고 할 때 접근 제한
    - 대기 가능 타이머(waitable timer) : 특정 시간이 되면 대기 중이던 스레드 깨움
    </details>


- Synchronized 키워드에 대해 설명해 주세요
    <details>

    - 멀티 스레드로 인하여 동기화를 제어하는 경우가 생기는데, 자바에서 제공하는 synchronized 키워드를 사용한다.
    - 멀티 스레드 상태에서 동일한 자원을 동시에 접근하게 되었을 때 동시 접근을 막는다.
    - “synchronized" 키워드가 의미하는 주요 목적은 다중 스레드 간의 상호작용을 동기화하여 데이터 무결성을 유지하고 경쟁 조건을 방지
    </details>

- Singleton 객체에 synchronized 키워드를 사용하면 생기는 문제점은?
    <details>

    Singleton 에 synchronized 메소드가 많을수록 멀티 스레드는 병목현상을 겪게 된다. 쉽게 말하자면 멀티 스레드를 사용하지만 Singleton 을 사용할 때는 싱글 스레드처럼 동작하는 문제가 발생한다.
    </details>

- synchronized 는 lock 을 이용해 동기화를 시키는데 총 4가지 사용법에 대해 아는 것이 있나요?
    <details>

    - synchronized method
        - 동기화를 시키고 싶은 클래스의 메소드에 `synchronized` 키워드를 붙이면 되고, `synchronized method` 는 인스턴스 단위의 `synchronized` 키워드가 붙은 메소드에 대해서만 `lock` 공유한다.
    - static synchronized method
        - `static synchronized method` 는 인스턴스가 아닌 클래스 단위로 `lock` 을 공유하며, `synchronized method` 와 동일하게 함수 간의 동기화가 발생한다. 만약 `synchronized method` 과 함께 사용하게 되면 인스턴스 락과 클래스 락은 공유가 안 되기 때문에 동기화 이슈가 발생할 수 있다는 점을 주의해야 한다.
    - synchronized block
        - `synchronized block` 은 `block` 단위로 `lock` 을 걸며, 2가지 사용 방법이 있다.
        - 첫번 째는 `synchronized` 의 인자 값에 `this` 를 사용하는 방식이다. 이 방식은 여러 스레드가 들어와 서로 다른 `block` 을 호출해도 `this` 를 사용해 자기 자신에 `lock` 을 걸었기 때문에 기다려야 한다.
        - 두번 쨰는 `synchronized` 의 인자 값에 `Object` 를 사용하는 방식이다. 이 방식은 `block` 마다 서로 다른 `lock` 을 걸리게해 훨씬 효율적인 코드를 작성할 수 있다.
    - static synchronized block
        - `static synchroinzed method`방식과 차이는 `lock`객체를 지정하고 `block`으로 범위를 한정지을 수 있다는 점이다. 클래스 단위로 `lock`을 공유한다는 점은 같다.
    </details>


- Thread-safe하게 프로그래밍 하려면?
    <details>

    - `volatile` : 캐시에 저장하지 않고 메모리에서 접근하겠다 (ex. 하나의 스레드만 RW하고 나머지는 R하는 경우)
    - `synchronized` 키워드 : Lock기법
    - `Atomic` 클래스 : CAS(Compare And Swap)기반, 특정 메모리 위치 값과 주어진 값을 비교해 같으면 새로운 값으로 변경
    </details>

- 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
    <details>

    1. **락 경합 (Lock Contention):** "synchronized" 블록 또는 메서드를 사용하면 한 번에 하나의 스레드만 해당 코드 영역에 접근할 수 있습니다. 이로 인해 다수의 스레드가 동일한 락을 경합하게 되면, 성능이 저하될 수 있습니다. 락 경합은 시스템 전반적인 처리량을 줄이고 대기 시간을 증가시킬 수 있습니다.
    2. **데드락 (Deadlocks):** 잘못 사용하면 "synchronized" 키워드로 인해 데드락 상황이 발생할 수 있습니다. 데드락은 두 개 이상의 스레드가 서로 락을 획득하려고 대기하며, 결과적으로 모든 스레드가 블록되어 더 이상 진행하지 못하는 상황을 의미합니다.
    3. **너무 큰 락 범위:** 큰 코드 블록이나 메서드를 동기화하면 락이 오래 지속될 수 있습니다. 이는 다른 스레드가 기다리는 시간을 증가시키며 성능을 저하시킬 수 있습니다. 락 범위를 작게 유지하여 스레드 간의 경합을 최소화하는 것이 중요합니다.
    4. **동기화의 대안:** Java 5 이후부터는 "synchronized" 대신 **`java.util.concurrent`** 패키지에 있는 동기화 클래스들을 활용하는 것이 권장됩니다. 이 패키지는 더 세밀한 동기화 제어를 제공하며 락 경합을 줄일 수 있는 방법을 제공합니다.
    </details>

### 고유락

- 동시성 프로그래밍에서 발생할 수 있는 문제는?
    <details>
    동시성 프로그램에서는 CPU와 RAM의 중간에 위치하는 CPU Cache Memory와 병렬성이라는 특징때문에 가시성 문제, 원자성 문제가 발생할 수 있다.
    </details>


- 가시성 문제와 원자성 문제에 대해 설명하라.
    <details>

    - 가시성 문제
        - 여러 개의 스레드가 사용됨에 따라, `CPU Cache Memory`와 `RAM`의 데이터가 서로 일치하지 않아 생기는 문제를 의미한다.
        - 가시성을 보장되어야 하는 변수에 `volatile` 키워드를 붙여줘서 `RAM`에서 바로 읽도록 해야 한다. 그러나 여러 스레드가 공유 자원에 쓰기 연산을 할 경우 가시성을 보장했다고 해서 동시성이 보장되지 않는다.
    - 원자성 문제
        - 여러 스레드가 공유 자원에 동시에 쓰기 연산을 할 경우 잘못된 결과를 반환하는 것을 의미한다. 따라서 `synchronized`, `atomic` 을 통해 원자성을 보장해야 한다.
    </details>


### IPC

- IPC 무엇인가요?
    <details>

    - 프로세스 통신을 위한 것
    - 프로세스가 통신이 가능하다. → 서로 다른 프로세스가 데이터를 주고 받을 수 있다.
    </details>


- 스레드 간 통신보다 프로세스 간의 통신이 어려운 이유가 무엇일까요?
    <details>

    - 프로세스는 생성되면서 PC를 포함한 메모리 공간 등을 복사하여, 별도의 자원을 할당한다.
    - 스레드는 메모리 공간과 자원을 공유한다.
    - 따라서 프로세스는 통신할 수 있는 공간이 없기 때문에 통신을 위한 별도의 공간을 만들어 주어야 하기 때문에 스레드 간 통신보다 어렵다.

    </details>


### CPU 스케줄링

- CPU 스케줄러란 무엇인가?
    <details>

    CPU가 유휴 상태가 될 때마다, 운영체제는 Ready Queue에 있는 프로세스 중에서 하나를 선택해 실행해야한다. 선택 절차는 CPU 스케줄러에 의해 수행된다.
    </details>


- 여러 CPU 스케줄링 알고리즘 사이에서 하나를 선택하기 위한 CPU 스케줄링 비교 기준이 있다면 어떤 것이 있을까요?
    <details>

    1. CPU 이용률
    2. 처리량
    3. 총처리 시간
    4. 대기 시간
    5. 응답 시간

    CPU 이용률과 처리량을 최대화 하고, 총처리 시간, 대기 시간, 응답 시간을 최소화 하는 알고리즘의 선택이 바람직하다.

    </details>


- 비선점형 스케줄링 기법 중에서 아는 거 하나만 말해주세요
    <details>

    FIFO는 First* In* First* Out(큐와 같음) 으로, 선입선출의 방식입니다. 즉, 먼저 Ready Queue에 들어온 프로세스부터 처리합니다. 대신, 비선점형 스케줄링이므로 아무리 작업시간이 길어도 해당 프로세스를 계속 실행해야합니다.

    SJF는 Shortest Job First 의 약자로, 평균 대기 시간을 최소화하기 위해 CPU 점유 시간이 가장 짧은 프로세스부터 CPU를 먼저 할당하는 방식입니다. 단점은 실행시간이 긴 프로세스는 짧은 프로세스들에게 밀려 무한히 대기해야 할 수 있습니다.

    HRN은 Highest Response* Ratio Next 의 약자로, SJF 기법을 보완하고자 대기시간과 실행시간을 이용하여 우선순위를 계산하고, 이러한 우선순위에 맞게 프로세스를 실행하는 기법입니다. 장점은 무한히 대기해야 하는 프로세스의 비율을 낮출 수 있습니다.
    </details>


- 선점 우선순위 스케줄링과 비선점 우선순위 스케줄링의 차이
    <details>

    - 선점 우선순위 스케줄링
        - 새로 도착한 프로세스의 우선순위가 현재 실행중인 프로세스의 우선순위보다 높으면 프로세서(CPU) 획득
    - 비선점 우선순위 스케줄링
        - 실행중인 것과 무관하게 우선순위가 높다면 큐의 제일 앞에 넣어준다.
    </details>


- 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스가 계속 들어오면 영원히 스케줄러에 선택받지 못하게 된다. 즉 기아 상태(Starvation)가 된다. 기아상태를 해결할 방법을 알고 있는가?
    <details>
    
    “에이징”이라는 기법을 이용하여 오래 대기하는 프로세스가 우선순위를 점진적으로 증가시켜주는 방법을 이용한다.
    </details>