## 공부 주제
- Array
- LinkedList
- Array & ArrayList & LinkedList
- Stack & Queue
- Heap
- Tree
- Binary Search Tree
- Hash
- Trie
- B-Tree & B+Tree

## 질문 

### 자료구조 질문

- **시간 복잡도와 공간복잡도에 대해 설명해주세요**

    <details>
    - 시간 복잡도 : 문제의 크기와 이를 해결하는 데 걸리는 시간 사이의 관계
    - 공간 복잡도 : 문제의 크기와 이를 해결하는 데 필요한 메모리 공간 사이의 관계
    </details>


- **O(1)은 O(N^2) 보다 무조건적으로 빠른가요?**

    <details>
    - O(1) : 입력 크기에 관계없이 일정한 실행시간을 가지는 알고리즘
        - 일정 시간을 가져, 안정적인 성능을 가지느다.
    - O(n^2) : 입력 크기의 제곱에 비례하는 실행시간을 가지는 알고리즘
    - 입력크기가 매우 작을 때에는 O(n^2)가 O(1) 보다 빠를 수 있지만, 일반적으로 O(1)이 더 빠르다.
    </details>

### Array

- **del 과 pop의 차이는 무엇인가?**

    <details>
    - del과 pop은 지우고자 하는 리스트의 인덱스를 받아서 지우는 방식
    - pop은 지워진 <인덱스의 값>을 반환하지만,
    - del은 반환하지 않는다.
    - 이 차이 때문에 미세하게 del이 pop 보다 수행속도가 더 빠르다.
    - remove와 동일하게 pop과 del은 특정 인덱스를 삭제한 다음 리스트를 재조정 한다.
    - del이 가장 빠르고, pop과 remove는 비슷한 수행시간을 갖는다.
    </details>

- **선형탐색 알고리즘과 이진 탐색 알고리즘의 차이에 대해 말해주세요**

    <details>
    - 선형 탐색 알고리즘 (Linear Search)
        - 리스트의 길이에 비례하는 시간 소요 : `O(n)`
        - 최악의 경우 : 모든 원소를 다 비교해야 한다
    - 이진 탐색 알고리즘 (Binary Serach)
        - 탐색하려는 리스트가 이미 정렬되어 있는 경우에만 적용 가능
        - 크기 순으로 정렬되어 있다는 성질을 이용
        - 한 번 비교가 일어날 때마다 리스트를 반씩 줄임
        - `O(logn)`
    </details>

### Linked-List

- **Linked List란 무엇이며, 어떻게 작동하는지 설명해주세요.**

    <details>
    - 구성 요소(Node)
        - data
        - Link (next)
    - 데이터의 모음을 저장하는 자료구조 중 하나
    - 각각의 데이터는 노드라고 불리는 객체로 표현되며, 이 노드는 데이터를 저장하는 데이터 필드와 다음 노드를 가리키는 포인터 필드로 구성
    - 이러한 방식으로 노드들이 연결된 구조를 가지고 있으며, 이 노드는 순서대로 나열
        - 첫번째 노드는 연결리스트의 head
        - 마지막 노드는 연결리스트의 tail
        - 중간에 새로운 노드를 삽입하거나, 노드를 삭제하거나, 검색하는 연산
    - Linked List의 장점
        - 삽입 삭제가 O(1)의 시간복잡도로 가능
    - 단점
        - 데이터를 검색하거나 특정 위치에 있는 데이터를 가져오는 데 O(n)의 시간복잡도가 필요하다
        - 데이터의 주소를 저장하므로, 배열보다 많은 메모리를 사용할 수 있다.
    </details>

- **마지막 노드는 연결리스트의 tail 이 필요한 이유에 대해 설명해주세요**

    <details>
    뒤에 삽입이 필요한다 할 때 앞에서부터 탐색하는 것 보다 tail에 하나를 더 붙이는게 효율적
    </details>

- **Singly Linked List와 Doubly Linked List의 차이점은 무엇인가요?**
  
    <details>
    - Doubly Linked-List
        - Singly Linked - List
            - 각 노드가 다음 노드를 가리키는 포인터 필드 하나만 가지고 있는 구조
            - 각 노드는 다음 노드에 대한 정보만 가지고 있으며, 이전 노드에 대한 정보는 가지고 있지 않다.
            - 각 노드는 다음 노드를 참조하여, 순서대로 연결된 구조를 가진다.
        - 각 노드가 이전 노드와 다음 노드를 모두 가리키는 포인터 필드 두개를 가지고 있는 구조
        - 각 노드는 이전 노드와 다음 노드에 대한 정보를 모두 가지고 있으며, 이전 노드와 다음 노드 모두에 대한 연결이 존재
    </details>

### Array vs ArrayList vs Linked-List

- **Array(List)의 가장 큰 특징과 그로 인해 발생하는 장점과 단점에 대해 설명해주세요.**

  <details>
  Array의 가장 큰 특징은 순차적으로 데이터를 저장한다는 점입니다.
  데이터에 순서가 있기 때문에 0부터 시작하는 index가 존재하며, index를 사용해 특정 요소를 찾고 조작이 가능하다는 것이 Array의 장점입니다.
  순차적으로 존재하는 데이터의 중간에 요소가 삽입되거나 삭제되는 경우 그 뒤의 모든 요소들을 한 칸씩 뒤로 밀거나 당겨줘야 하는 단점도 있습니다.
  이러한 이유로 Array는 정보가 자주 삭제되거나 추가되는 데이터를 담기에는 적절치 않습니다.
  </details>

- **Array를 적용시키면 좋을 데이터의 예를 구체적으로 들어주세요. 구체적 예시와 함께 Array를 적용하면 좋은 이유, 그리고 Array를 사용하지 않으면 어떻게 되는지 함께 설명해주세요**

  <details>
  Array를 적용시키면 좋은 예로 주식 차트가 있습니다.
  주식 차트에 대한 데이터는 요소가 중간에 새롭게 추가되거나 삭제되는 정보가 아니며, 날짜별로 주식 가격이 차례대로 저장되어야 하는 데이터입니다.
  즉, 순서가 굉장히 중요한 데이터이므로 Array 같이 순서를 보장해주는 자료구조를 사용하는 것이 좋습니다.
  Array를 사용하지 않고 순서가 없는 자료 구조를 사용하는 경우에는 날짜별 주식 가격을 확인하기 어려우며 매번 전체 자료를 읽어 들이고 비교해야 하는 번거로움이 발생합니다.
  </details>

- **Array와 ArrayList의 차이점에 대해 설명해주세요.**

  <details>
  Array는 크기가 고정적이고, ArrayList는 크기가 가변적입니다.
  Array는 초기화 시 메모리에 할당되어 ArrayList보다 속도가 빠르고,
  ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array보다 느립니다.</details>


  


### Stack & Queue

- **Stack과 큐의 차이점에 대해 말해주세요 & 어떤 상황에서 사용되는지 말해주세요**
  
    <details>
    - 스택
        - 자료를 선형적으로 저장하는 자료구조
        - 마지막에 삽입된 자료가 가장 먼저 꺼내진다.
        - 수식 계산, 함수 호출, 브라우저의 뒤로 가기
    - 큐
        - 자료를 일렬로 저장하는 자료 구조
        - 처음에 삽입된 자료가 가장 먼저 꺼내지는 FIFO
        - 대기열 처리, 너비우선탐색, 캐시</details>

    
  
  
- **스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과, 그 시간복잡도에 대해 설명해 주세요.**

    <details>
    - 스택 2개로 큐
        - 하나의 스택은 데이터를 저장하기 위한 스택
        - 다른 하나의 스택은 역순으로 데이터를 저장하기 위한 스택
        - 데이터를 삽입하기 위해서는 먼저 데이터를 역순으로 저장하는 스택에 데이터를 삽입하고, 그 다음 데이터를 저장하는 스택에서 데이터를 삽입
        - 데이터를 삭제하기 위해서는 역순으로 저장된 스택에서 데이터를 팝하면 큐에서 가장 오래된 데이터를 삭제할 수 있습니다.
    - 큐 2개로 스택
        - 데이터를 삽입할 때는 하나의 큐에 데이터를 삽입
        - 데이터를 삭제할 때는 다른 큐로 모든 데이터를 이동시키면서
        - 가장 마지막에 삽입된 데이터를 제거
    </details>

- **Stack과 Queue의 실사용 예를 들어 간단히 설명해주세요.**

    <details>
    Stack - 자바의 Stack 메모리 영역
    지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드 호출시 메모리에 할당되고 종료되면 메모리가 해제되며,
    LIFO(Last In First Out)구조를 가집니다.
    <br><br>
    Queue - OS의 스케쥴러
    자원의 할당과 회수를 하는 스케쥴러 역할을 큐가 할 수 있습니다.
    메모리에 적재된 다수의 프로세스 중 어떤 프로세스에게 자원을 할당할 것인가 그 순서를 결정하는 것이 자원의 효율적인 사용에 있고,
    가장 단순한 형태의 스케쥴링 정책이 선입선처리(First Com First Served) 즉, 큐라고 볼 수 있습니다.
    </details>
    
- **원형 큐에 대해 설명해주세요**

    <details>
    - 큐에 빈 메모리가 남아 있어도, 꽉 차있는 것으로 판단할 수 있다.
    - 논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 간주함
    - 공백, 포화 상태를 구분하기 위해 자리 하나를 항상 비워둔다.
    </details>


### 힙 (heap)

- **우선순위 큐에 대해 설명해주세요**

    <details>
    - 큐는 먼저 들어오는 데이터가 먼저 나가는 FIFO형식의 자료구조
    - 우선순위 큐는 먼저 들어오는 데이터가 아니라, 우선순위가 높은 데이터가 먼저 나가는 형태의 자료구조
        - 힙을 이용하여 구현
    </details>

- **최대힙과 최소힙의 차이에 대해 말해주세요**
  
    <details>
    - 최대힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
    - 최소힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리
    </details>


### 트리

- 그래프와 트리의 차이에 대해 말해주세요

    <details>
    - 그래프
        - 방향성 : 방향 그래프 혹은 무방향 그래프
        - 순환성 : 순환 및 비순환
        - 루트 노드 존재 여부 : 루트 노드가 없음
        - 노드 간 관계성 : 부모와 자식 관계 없음
        - 모델의 종류 : 네트워크 모델
    - 트리
        - 방향성 : 방향그래프
        - 순환성 : 비순환
        - 루트 노드 존재 여부 : 루트 노드가 존재
        - 노드 간 관계성 : 부모와 자식 관계
        - 모델의 종류 : 계층 모델
      </details>

- **이진 트리에 대해 말해주세요**

    <details>
    - 모든 노드의 차수가 2 이하인 트리
    - 재귀적으로 정의할 수 있다.
    - 루트노드 + 왼쪽 서브트리 + 오른쪽 서브트리
    </details>


### 이진 탐색 트리

- **이진 탐색 트리란 무엇인가요?**

    <details>
    - 이진탐색 : **탐색에 소요되는 시간복잡도는 O(logN)**, but 삽입,삭제가 불가능
    - 연결리스트 : **삽입, 삭제의 시간복잡도는 O(1)**, but 탐색하는 시간복잡도가 O(N)
    - 이 두가지를 합하여 장점을 모두 얻는 것이 **'이진탐색트리'**
    - 즉, 효율적인 탐색 능력을 가지고, 자료의 삽입 삭제도 가능하게 만들자
    </details>

- **이진 탐색 트리의 특징**

    <details>
    - 각 노드의 자식이 2개 이하
    - 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큼
    - 중복된 노드가 없어야 함
    </details>

- **이진트리와 이진탐색 트리의 차이점에 대해 말해주세요**

    <details>
    - 이진탐색 트리
        - 왼쪽 자식 노드의 값은 현재 노드의 값보다 작습니다.
        - 오른쪽 자식 노드의 값은 현재 노드의 값보다 큽니다.
    - 이진탐색트리는 데이터를 정렬된 상태로 저장하기 위해 사용되는 자료구조
    - 이진트리와 이진탐색트리의 가장 큰 차이점은 노드들의 정렬 여부
    - 이진탐색트리는 모든 노드가 정렬되어 있기 때문에 검색과 삽입, 삭제 연산이 빠르게 수행될 수 있습니다
    - 이진트리는 정렬되어 있지 않기 때문에 검색 연산의 경우 모든 노드를 탐색해야 하는 최악의 경우(O(N))가 발생할 수 있습니다.
    </details>

- 이진탐색트리가 효율적이지 못한 경우를 말해주세요
  
    <details>
    한쪽으로 치우쳐진 균형이 이루어지지 않은 이진탐색 트리 -> 선형 탐색과 동등한 복잡도를 가진 경우
    - O(n)
    - 그러면 이진탐색트리를 사용할 이유가 있을까?
      - 이를 바로잡기 위해
      - AVL Tree, RedBlack Tree
        </details>


### 해시 (Hash)

- **해시의 장점&단점에 대해 말해주세요**

    <details>
    - 해시테이블은 key-value가 1:1로 매핑되어 있기 때문에 삽입, 삭제, 검색의 과정에서 모두 평균적으로O(1)의 시간복잡도를 가지고 있다.
    - 단점
        - 해시 충돌이 발생
        - 순서/관계가 있는 배열에는 어울리지 않는다.
        - 공간 효율성이 떨어진다.
    </details>

- **해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?**

    <details>
    1. 체이닝 : 연결리스트로 노드를 계속 추가해나가는 방식 (제한 없이 계속 연결 가능, but 메모리 문제) <br>
    2. Open Addressing: 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용 (해당 키 값에 저장되어있으면 다음 주소에 저장) <br>
    3. 선형 탐사 : 정해진 고정 폭으로 옮겨 해시값의 중복을 피함 <br>
    4. 제곱 탐사 : 정해진 고정 폭을 제곱수로 옮겨 해시값의 중복을 피함 <br>
    </details>

- **파이썬에서, 어떤 방식으로 해시 충돌을 처리하나요?** (각 본인이 사용하는 언어를 기준으로 hash 충돌 처리 원리에 대한 이해를 합시다 !)
  
    <details>
    파이썬의 딕셔너리(dict) 타입은 내부적으로 해시 테이블을 사용하며, 이를 통해 매우 빠른 검색과 삽입을 제공합니다. 하지만, 해시 충돌이 발생하면 체이닝을 통해 해결하므로, 최악의 경우에는 검색 및 삽입이 O(n)의 시간복잡도를 가질 수 있습니다. 그러나 대부분의 경우에는 충돌이 거의 발생하지 않기 때문에, 딕셔너리 타입은 매우 높은 성능을 보입니다.

    출처 : GPT (불확실할 수 있으니 개인이 더 공부해보기)
    </details>


### B-Tree & B+Tree

- **B-Tree란**

    <details>
    - 이진 트리를 확장해서 많은 자식을 갖을 수 있는 균형 트리
    - key들이 항상 오름차순으로 정렬되어 구성
    - Branch와 Leaf 노드가 key와 data를 저장
    </details>

- **B+Tree란**

    <details>
    - B트리를 확장해서 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드를 추가한 트리(리프들이 연결되어 있음)
    - Branch 노드는 key만 저장-하나의 노드에 더 많은 key를 담을 수 있게 되므로 트리의 높이가 B 트리에 비해 더 낮아진다.(cache hit를 높임)
    - Leaf 노드는 Key와 Data를 저장하고 Linked List로 연결되어 있음(검색에 유용)
    </details>

- **B+트리는 B-트리의 어떤 문제점을 해결하고자 등장했나요?**
  
    <details>
    B-트리의 순회작업에 대한 문제점. <br>풀 스캔 시 B트리는 모든 노드를 확인해야하지만, B+ 트리의 경우 리프노드에 연결된 연결리스트로 선형 탐색이 가능하다.
    </details>
    
- **그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?**
  
    <details>
    B Tree의 경우 best case에는 루트에서 끝날수 있지만, B+Tree의 경우 무조건 leaf노드까지 가야한다.
    </details>
    
-  **기존 B+트리와 InnoDB의 B+트리와의 차이점은 뭘까요?**

    <details>
    기존 B+트리는 리프노드가 SingleLinkedList이지만, InnoDB의 리프노드는 DoubleLinkedList있고 자식노드로는 SingbleLinkedList로 연결되어있다. 등등
    </details>

    

## 정리 링크

* 세정 : [자료구조 질문 정리](https://evening-november-9ec.notion.site/15-8188fa8e3aff49ca9ce02158b30dc946)

* 수민 : https://sustco.tistory.com/46 (1234)
