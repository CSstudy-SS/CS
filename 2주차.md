1. 프로그램과 프로세스의 차이점은 무엇일까요?
    <details>
        <summary>답변보기</summary>
        프로그램은 우리가 코딩을 하는 코드 뭉텅이라고 생각하면 편함.<br>
        프로그램 - 파일 시스템에 존재하는 실행파일<br>
        프로세스 - 프로그램이 실행되어 메모리가 할당되어 메모리 상에 올라간 프로그램
    </details>
2. 프로세스와 스레드의 차이점은 무엇일까요?
     <details>
        <summary>답변보기</summary>
        프로세스는 하나 이상의 스레드에 의해 실행되는 프로그램의 인스턴스이며, 스레드는 프로세스 내에 존재하는 독립적인 실행단위이다.<br>
        각 스레드는 stack 영역을 제외한 프로세스의 메모리 공간과 다른 리소스를 공유합니다.
    </details>
3. 멀티스레드에서의 공유자원에 대해 설명해주실수 있나요?
   <details>
        <summary>답변보기</summary>
        각 스레드는 stack을 제외한 프로세스의 메모리공간을 공유하기 때문에, 멀티프로세스 보다 적은 메모리를 사용합니다.
    </details>
4. stack과 heap의 크기가 결정되는 시점은 언제인가요?
    <details>
        <summary>답변보기</summary>
        일반적으로 운영체제는 프로그램을 실행할 때 스택 영역의 초기 크기를 설정합니다. 이 초기 크기는 컴파일러나 런타임 라이브러리에서 지정된 기본값을 사용하거나, 운영체제에서 지정한 기본값을 사용할 수 있습니다.<br>
        heap의 크기는 프로그래머에 의해 결정되며 프로그램 실행중에 동적으로 변경된다.</details>
    
    <details>
        <summary>스택의 크기 결정시점에 대한 gpt4 답변</summary>
        <br><br>
    스택의 크기 결정시점에 대한 gpt4 답변V<br><br>
    스택의 크기는 프로그램이 실행되는 동안 동적으로 결정됩니다. 스택의 크기는 프로그램에서 함수를 호출하고 반환할 때마다 변경됩니다.<br>일반적으로 운영체제는 프로그램을 실행할 때 스택 영역의 초기 크기를 설정합니다. 이 초기 크기는 컴파일러나 런타임 라이브러리에서 지정된 기본값을 사용하거나, 운영체제에서 지정한 기본값을 사용할 수 있습니다.<br>하지만 프로그램이 실행되면서 함수를 호출하고 반환하는 등의 작업을 수행하면서 스택의 크기가 동적으로 변합니다. 예를 들어, 함수를 호출할 때마다 호출된 함수의 인자값과 지역 변수 등이 스택에 저장되고, 함수를 반환할 때 이들이 스택에서 제거됩니다. 따라서 스택의 크기는 이러한 작업을 수행하는 동안 동적으로 결정됩니다.<br>스택의 크기가 너무 작거나 크면 프로그램의 실행 중에 스택 오버플로우나 스택의 낭비 등의 문제가 발생할 수 있습니다. 따라서 스택의 크기를 조정하여 적절한 크기로 유지하는 것이 중요합니다. 스택의 크기를 조정하는 것은 컴파일러나 런타임 환경에서 제공하는 설정 옵션으로 조정할 수도 있습니다. 디버깅할 때도 스택의 크기를 적절하게 조정하여 디버깅을 수행하는 것이 좋습니다.
    </details>
    
    
5. stack과 Heap 중 접근 속도가 빠른 공간은 어디일까요?
    <details>
        <summary>답변보기</summary>
        <p>stack이 빠릅니다.<p>
        stack의 경우는 이미 메모리 상에 할당이 되어 있기 때문에 코드를 컴파일 할때 스택에 있는 변수의 위치를 알고 있지만, heap은 사용자에 따라 동적으로 할당하는 공간이기 때문에 컴파일러가 어느 위치에 변수가 저장되어있는지를 알고 있지 않다.
    </details>
    
    <details>
        <summary>gpt4 답변</summary>
    <br><br>
        일반적으로 stack이 heap보다 더 빠른 접근 속도를 가집니다. 이는 stack이 메모리의 연속된 공간을 사용하고, 특정한 메모리 주소를 기준으로 스택 포인터(Stack Pointer)가 상대적으로 적은 메모리 주소로 이동하면서 스택 프레임(Stack Frame)을 생성하고 삭제하기 때문입니다.
    <br><br>
    반면, Heap은 동적 할당(Dynamic Allocation)된 메모리 공간을 사용하고, 여러 개의 조각으로 분산되어 있을 수 있습니다. 이는 메모리 할당 및 해제 시에 포인터와 인덱싱 연산을 통해 메모리 주소를 계산해야 하므로 stack에 비해 접근 속도가 느릴 수 있습니다.
    <br><br>
    그러나, 이는 일반적인 경우에 해당하는 이야기이며, 실제 접근 속도는 시스템 환경 및 사용 방법에 따라 달라질 수 있습니다. 또한, 최근의 하드웨어와 컴파일러는 메모리 접근 최적화를 수행하므로, 성능 상의 차이가 크지 않을 수도 있습니다.
    </details>
6. 재귀함수를 너무 많이 호출하면 나오는 오류와 그 오류가 발생하는 이유는 무엇인가요?
    <details>
        <summary>답변보기</summary>
        stack overflow
        함수를 호출할때 지역변수나 매개변수 등이 stack에 쌓이게 되는데, 너무 많은 함수 호출로 인해 stack이 꽉차면 stackoverflow 발생
    </details>
7. 동시성과 병렬처리의 차이점?
    <details>
        <summary>답변보기</summary>
        동시성의 경우 멀티프로세스나 멀티스레드 방식을 이용하여 context switching을 이용하여 동시에 실행하는 것처럼 보이게 하는 것을 의미<br>
        병렬성은 멀티코어 즉 물리적인 코어가 여러개인 점을 이용해 동일한 시간에 독립적인 작업을 실행할 수 있음을 의미한다.
    </details>
8. 크롬과 IE의 차이점과 장단점? (멀티프로세스와 멀티스레드의 예시)
    <details>
        <summary>답변보기</summary>
        크롬은 멀티프로세스 방식이다.
        IE는 멀티스레드 방식이다.
        크롬의 경우 멀티프로세스 방식이기 때문에 각각의 탭이 각각의 프로세스이기 때문에 각 프로세스가 독립되어 있어 서로 영향을 미치지 않지만, 많은 메모리를 사용한다.<br>
        IE의 경우 멀티스레드 방식이기 때문에 메모리의 사용량이 상대적으로 적지만 하나의 탭이 오류로 인해 종료되었을 때 모든 탭에 영향을 끼치며 모든 탭이 비정상적으로 종료되는 현상이 발생 할 수 있다.
    </details>
9. PCB란 무엇인가요?
    <details>
        <summary>답변보기</summary>
        특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 프로세스를 표현하는 자료구조이다.
    </details>
10. 프로세스의 주소공간이란?
    <details>
        <summary>답변보기</summary>
        프로세스가 메모리를 할당 받고, 이 할당 받은 메모리를 관리하기 위한 공간<br>stack, heap, data, text로 이루어져 있다.
    </details>
11. 리눅스에서 프로세스와 스레드는 어떻게 생성될까요?
    <details>
        <summary>답변보기</summary>
        리눅스에서는 기본적으로 새로운 프로세스가 생성될때 fork() 명령어가 실행된다.<br>
        fork()로 자신과 동일한 자식 프로세스를 생성한 뒤, exec()명령어로 다른 프로세스로 보이게 변경한다.
        <br>
        fork()를 통해 자식프로세스를 만들면 너무 메모리 사용량이 크므로 리눅스에서는 쓰레드를 만들기 위해 자식프로세스를 동일하게 만들지만 부모프로세스의 PCB정보를 포함하여 포인터형태로 가지게 된다.
        <br>
        그래서 프로세스이지만 상대적으로 가볍기 때문에 필요한 작업만을 처리할 수 있어서 `가벼운 프로세스`라고 부르기도 한다.
        linux 시스템에서는 fork() 명령어로 프로세스를 생성, clone() 명령어로 스레드를 생성할 수 있다.
    </details>

   조금 더 자세한 설명이 필요하시면 [https://www.notion.so/Week2-1de0cc8d256a45a6b642535b3bf3e649](https://spot-visitor-fff.notion.site/Week2-1de0cc8d256a45a6b642535b3bf3e649)



## 각자 정리한 부분

* 수민 : https://sustco.tistory.com/33 (비밀번호 : 1234)
* 세정 : https://evening-november-9ec.notion.site/2-1e85b7a22df147e984affb11ec638d19
