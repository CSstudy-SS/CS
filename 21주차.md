### 공부 주제 (복습 + 추가)

- 키(Key) 정리
- SQL - JOIN
- SQL Injection
- SQL vs NoSQL
- 정규화(Normalization)
- 이상(Anomaly)


## 질문

- Key (기본키, 후보키, 슈퍼키 등등)에 대해 설명해주세요

    <details>

    - 후보키 중 PK를 제외한 나머지 후보키는 대체키(Alternate Key)이다.
    - 외래키(Foreign Key)는 각 테이블끼리 관계를 맺어줄 때 사용한다.
    - 슈퍼키(Super Key)는 최소성 없이 단지 튜플을 식별하기 위해 두개 이상의 속성들의 집합으로 만들어진 키를 의미한다.
    </details>

- 기본키는 수정이 가능한가요?

    <details>

    기본키(Primary Key)는 수정이 가능하지 않습니다. 
    
    기본키는 테이블의 각 행을 고유하게 식별하는 역할을 하며, 데이터 무결성을 유지하기 위해 사용됩니다. 기본키는 특정 행을 식별하고 조회하거나 다른 테이블과의 관계를 맺을 때 사용됩니다.

    기본키의 값이 수정되는 경우, 해당 행이 다른 행들과의 관계가 깨질 수 있으며 데이터의 일관성이 손상될 수 있습니다. 따라서 일반적으로 기본키는 생성 후에는 수정되지 않도록 설계됩니다.

    ```
    준엽님 & 원형님 프로젝트를 하면서 기본키 값을 수정한 경험이 있었음!
    -> MySQL에서는 삭제 후 추가를 "수정"하는 것
    ```
    </details>


- 만약 기본키 값을 수정해야 한다면 어떻게 할 수 있나요?

    <details>

    만약 기본키의 값을 수정해야 한다면, 일반적으로 기존의 기본키 값을 유지한 채로 새로운 기본키 값을 추가하거나, 기존의 기본키 값을 완전히 변경하는 대신 대체키(Surrogate Key)를 사용하는 방법을 고려할 수 있습니다.
    
    이렇게 함으로써 기본키의 값이 변경되지 않고 데이터의 일관성을 유지할 수 있습니다.
    </details>

- 외래키 값은 NULL이 들어올 수 있나요?

    <details>

    네. 들어올 수 있습니다. -> 개발자의 옵션 설정으로 컨트롤 가능

    외래키의 NULL 값 허용 여부는 데이터베이스 시스템과 해당 테이블의 설계 및 제약 조건에 따라 다를 수 있습니다. 
    데이터베이스의 관리자 또는 개발자는 외래키에 대한 NULL 값을 허용할지 여부를 결정하고, 이에 따라 적절한 제약 조건을 설정할 수 있습니다.
    </details>

- db에서 JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.

    <details>

    - Nested Loop Join
      - Nested Loop Join은 가장 간단한 JOIN 알고리즘 중 하나입니다.
      - 두 개의 테이블을 중첩 반복문으로 순회하면서 매칭되는 레코드를 찾습니다. 이 알고리즘은 간단하지만, 큰 테이블을 가지고 JOIN을 수행할 경우 성능 문제가 발생할 수 있습니다.
    - Sort Merge Join
        - Sort Merge Join은 두 개의 테이블을 각각 정렬한 후에 병합하는 방식으로 JOIN을 수행합니다.
        - 이 알고리즘은 정렬이 필요하므로 많은 자원과 시간이 소요될 수 있습니다. 그러나 정렬된 데이터를 병합하는 방식이므로, 메모리가 제한적인 경우에도 사용할 수 있습니다.
    - Hash Join
        - Hash Join은 두 개의 테이블에서 해시 함수를 사용하여 매칭되는 레코드를 찾는 방식으로 JOIN을 수행합니다.
        - 이 알고리즘은 많은 자원을 요구하지만, 빠른 성능을 보장합니다. 해시 함수를 사용하기 때문에 레코드의 키 값을 해싱하여 메모리에 저장해야 하므로, 메모리가 부족한 경우에는 문제가 될 수 있습니다.
    - Merge Join with Indexes
        - Merge Join with Indexes는 두 개의 테이블에서 인덱스를 사용하여 JOIN을 수행하는 방식입니다.
        - 인덱스를 사용하기 때문에 테이블을 스캔하지 않아도 되므로, Nested Loop Join 보다 빠른 성능을 보장할 수 있습니다. 그러나 인덱스를 만드는데 시간과 자원이 많이 필요하므로, 인덱스를 미리 만들어 놓는 것이 좋습니다.

    </details>


- 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면, JOIN의 성능도 인덱스의 유무의 영향을 받나요?

    <details>
    JOIN 연산의 성능은 인덱스의 유무와 관련이 있습니다. 인덱스는 데이터베이스에서 효율적인 데이터 검색을 위해 사용되는 구조이며, JOIN 연산에도 영향을 미친다.

    1. 조인 조건에 사용되는 열에 인덱스가 있을 경우:
        - 조인 조건에 사용되는 열에 인덱스가 있다면, DBMS는 인덱스를 활용하여 조인 연산을 수행합니다.
        - 인덱스를 사용하면 조인할 테이블의 검색 속도가 향상되어 조인 연산이 더 효율적으로 수행될 수 있습니다.
        - 인덱스를 통해 조인에 필요한 데이터를 빠르게 찾을 수 있으므로, 처리 시간과 자원 사용을 줄일 수 있습니다.
    2. 조인에 사용되는 열에 인덱스가 없는 경우:
        - 조인에 사용되는 열에 인덱스가 없으면 DBMS는 전체 테이블 스캔을 수행하여 조인을 수행해야 합니다.
        - 인덱스가 없는 경우에는 전체 테이블을 스캔해야 하므로 처리 시간이 길어질 수 있고, 자원 사용도 많이 필요할 수 있습니다.

    적절한 인덱스를 사용하면 조인 연산의 속도를 향상시킬 수 있으며, 반대로 인덱스의 부재나 부적절한 인덱스 구성은 JOIN 연산의 성능 저하를 야기할 수 있습니다. 데이터베이스 설계와 쿼리 최적화 단계에서 인덱스를 고려하여 적절한 인덱스를 생성하고 관리하는 것이 중요합니다.
    </details>


- 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?

    <details>

    WHERE 절에서 UNIQUE 열을 사용하는 쿼리는 특정 값에 대한 빠른 조회 시간을 제공하는 고유 인덱스의 이점을 얻을 수 있습니다. 

    UNIQUE 열에서 특정 값을 검색할 때 고유 인덱스를 사용하면 MySQL이 전체 테이블을 검색하는 대신 해당 값을 포함하는 정확한 행을 빠르게 찾을 수 있습니다.
    WHERE 절에서 UNIQUE 열을 사용하지 않는 쿼리는 고유 인덱스의 이점을 얻지 못할 수 있습니다. 
    이 경우 MySQL은 필요한 데이터를 검색하기 위해 전체 테이블 검색을 수행해야 할 수 있으며, 이는 인덱스를 사용하는 것보다 느릴 수 있습니다.

    따라서 UNIQUE 키워드가 연결된 열을 사용하는 쿼리의 성능은 특히 해당 열에서 특정 값을 검색할 때 그렇지 않은 쿼리보다 빠를 수 있습니다. 
    그러나 전체 성능은 테이블의 크기, 쿼리되는 열 수, 쿼리의 복잡성, 사용되는 특정 인덱스 등 다양한 요인에 따라 달라집니다.
    </details>

- SQL SELECT 쿼리 문법 순서와 실행 순서에 대해서 설명해 주세요.
    <details>

    - SQL 문법 순서 : SELECT -> FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY
    - SQL 실제 실행 순서 : FROM(각 테이블 확인) -> ON(조인 조건 확인) -> JOIN(테이블 조인(병합)) -> WHERE(데이터 추출 조건 확인) -> GROUP BY(특정 칼럼으로 데이터 그룹화) -> HAVING(그룹화 이후 데이터 추출 조건 확인) -> SELECT(데이터 추출) -> DISTINCT(중복 제거) -> ORDER BY(데이터 정렬) -> LIMIT
    </details>

- SQL종류?
    <details>

    - DML : 데이터 조작 - Select, Insert, Update, Delete
    - DDL : 데이터(구조, 객체) 정의 - Create, Drop(테이블 삭제), Truncate(테이블 데이터 삭제, 테이블 초기화), Alter
    - DCL : 권한 제어 - Grant, Revoke
    </details>


- 정규화는 어떤 배경에서 생겨났는가?
    <details>

    한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장 공간을 낭비하게 된다. 또 중복된 정보로 인해 갱신 이상이 발생하게 된다. 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 어느 것이 정확한지 알 수 없게 되는 것이다. 이러한 문제를 해결하기 위해 정규화 과정을 거치는 것이다.
    </details>

- 이상에는 어떠한 것들이 있는가
    <details>

    - 삽입 이상(insertion anomalies) 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점을 말한다.
    - 삭제 이상(deletion anomalies) 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점을 말한다.
    - 수정(갱신)이상(modification anomalies) 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점을 말한다.
    </details>

- 그래서 정규화란 무엇인가?
    <details>
    관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 좀 더 구체적으로는 불만족스러운 나쁜 릴레이션의 애트리뷰트들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업을 말한다. 정규화 과정을 거치게 되면 정규형을 만족하게 된다. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1 정규형, 제 2 정규형, 제 3 정규형, … 등이 존재한다.
    </details>

- 정규화에는 어떠한 장점이 있는가?
    <details>

    1. 데이터베이스 변경 시 이상 현상(Anomaly) 제거 위에서 언급했던 각종 이상 현상들이 발생하는 문제점을 해결할 수 있다.
    2. 데이터베이스 구조 확장 시 재 디자인 최소화 정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다. 이는 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되며 응용프로그램의 생명을 연장시킨다.
    3. 사용자에게 데이터 모델을 더욱 의미있게 제공 정규화된 테이블들과 정규화된 테이블들간의 관계들은 현실 세계에서의 개념들과 그들간의 관계들을 반영한다.
    </details>

- 단점은 없는가?

    <details>
    릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 

    이로 인해 질의에 대한 응답 시간이 느려질 수 있다. 조금 덧붙이자면, 정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 입력/수정/삭제 이상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.
    </details>

- 단점에 대한 대응책은?

    <details>
    반정규화(De-normalization, 비정규화)

    `반정규화`는 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다. 디스크 I/O 량이 많아서 조회 시 성능이 저하되거나, 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나, 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다. 일반적으로 조회에 대한 처리 성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려하게 된다.
    </details>



- Replciation과 Clustering에 대해 설명해 주세요.
    <details>
    
    - 리플리케이션(Replciation)
      - 여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식입니다.
      - 비동기 방식으로 노드들 간의 데이터를 동기화합니다.
      - 장점 : 비동기 방식으로 데이터가 동기화되어 지연 시간이 거의 없습니다.
      - 단점 : 노드들 간의 데이터가 동기화되지 않아 일관성있는 데이터를 얻지 못할 수 있습니다.
      
    - 클러스터링(Clustering)
      - 여러 개의 DB를 수평적인 구조로 구축하여 Fail Over한 시스템을 구축하는 방식입니다.
      - 동기 방식으로 노드들 간의 데이터를 동기화합니다.
      - 장점 : 1개의 노드가 죽어도 다른 노드가 살아 있어 시스템을 장애없이 운영할 수 있습니다.
      - 단점 : 여러 노드들 간의 데이터를 동기화하는 시간이 필요하므로 리플리케이션에 비해 쓰기 성능이 떨어집니다.
    </details>

- 샤딩과 파티셔닝의 차이?
    <details>

    - 파티셔닝(Partitioning)
      - 퍼포먼스(performance), 가용성(availability) 또는 정비용이성(maintainability)를 목적으로 당신의 논리적인 데이터 엘리먼트들을 다수의 엔티티(table)로 쪼개는 행위를 뜻하는 일반적인 용어이다.
      - 수평 파티셔닝 : 데이터베이스를 샤딩하게 되면 기존에 하나로 구성될 스키마를 다수의 복제본으로 구성하고 각각의 샤드에 어떤 데이터가 저장될지를 샤드키를 기준으로 분리한다.
      - 수직 파티셔닝 : 하나의 엔티티에 저장된 데이터들을 다수의 엔티티들로 분리하는것을 말한다.

    여기서 수평 파티셔닝이 샤딩과 동일. 파티셔닝은 퍼포먼스, 가용성, 정비용이성등의 목적을 위해 논리적인 엔티티들을 다른 물리적인 엔티티들로 나누는것을 의미하는 일반적인 용어이다. 
    
    수평 파티셔닝 또는 샤딩은 스키마 복제 후 샤드키를 기준으로 데이터를 나누는것을 말한다. 수직 파티셔닝은 스키마를 나누고 데이터가 따라 옮겨가는것을 말한다.
    </details>

- 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?
    <details>
    __요점은 레플리케이션 방식과 샤딩 방식의 장단점 설명__

    레플리케이션은 데이터의 가용성(하나의 노드가 실패하더라도 다른노드에서 데이터 액세스 가능)과 내구성(같은 데이터의 복사본이 다른 노드에도 존재)을 향상시키며, 
    읽기 성능(읽기 요청이 여러 노드에 분산될 수 있음)을 향상시키는 데 중점을 두고 있습니다. 
    
    반면에 샤딩은 데이터베이스의 확장성(샤드를 별도의 서버에서 호스팅 가능, 수평정확장)을 향상시키며, 쓰기 성능(쓰기 작업이 여러 샤드에 분산)을 향상시키는 데 중점을 두고 있습니다.

    </details>


### 정리 링크

