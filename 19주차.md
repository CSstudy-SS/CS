
### 공부 주제(복습 + 추가)

- OSI 7 Layer
- 3 way - 4 way handshake
- 혼잡제어 & 흐름제어
- UDP
- 대칭키 & 공개키


## 질문

### 네트워크 통합

- 유니캐스트, 멀티캐스트, 브로드캐스트란? 
  <details>
  
    - 유니캐스트 : 특정 대상과 1:1 통신
    - 멀티캐스트 : 특정 다수와 1:N 통신
    - 브로드캐스트 : 네트워크에 있는 모든 대상과 통신
  </details>

### OSI 7 Layer

- **계층화 모듈화(OSI 7 Layer)의 이점은? <br>-> network layer와 data link layer을 설명하고, 차이점을 설명하세요 <br>-> 라우팅에 대해 아는가?**

  <details>
  [계층화 모듈화(OSI 7 Layer)의 이점은?]<br>
  1. 단순성과 이식성 <br>
  2. 유지 보수 및 디버깅 용이성<br>
  3. 기능적 확장성<br>
  <br>
  [network layer와 data link layer을 설명하고, 차이점을 설명하세요]<br>
  네트워크 계층: 상이한 네트워크 사이의 라우팅 및 데이터 전송을 처리합니다. 이 계층에서 가장 중요한 프로토콜은 IP와 ICMP입니다. <br>
  데이터 링크 계층: 동일한 네트워크에 있는 장치 간의 통신을 처리합니다. 계층 3을 우편물의 주소로 생각하며 계층 2는 해당 주소에 있는 사무실 번호 또는 아파트 호수를 지시한다고 생각할 수 있습니다. 이 계층에서는 이더넷이 가장 많이 사용되는 프로토콜입니다.<br>
  <br>
  [라우팅에 대해 아는가?]<br>
  라우팅은 네트워크에서 데이터 패킷이 출발지에서 목적지로 전달되는 경로를 결정하는 과정이나 알고리즘을 말한다. 벨만포드, 다익스트라 알고리즘이 라우팅 알고리즘으로 사용된다.<br>
  <br>
  [게이트웨이란?]
  네트워크를 다른 네트워크와 연결할 때 연결점이 되는 장치<br>
  게이트웨이도 하나의 컴퓨터로 보통 라우터라고 함<br>
  게이트웨이 주소가 설정되어 있지 않으면 같은 네트워크가 아닌 컴퓨터와 접속 할 수 없음
  </details>

- 데이터 링크 레이어와 트렌스포트 레이어 모두 오류제어기능을 제공한다. 두 오류제어 기능의 차이는?

  <details>

  데이터 링크 계층에서는 오류가 난 프레임을 버려버리는 방식이지만, 트랜스포트계층의 오류제어는 오류가 생기면 재발송함으로써 오류복구까지 해준다.
  </details>

- 사용자가 웹브라우저를 통해 서버에 이미지를 요청해서 사용자에게 보여주기까지 과정을 설명하세요

  <details>

  [참고했던 블로그](https://krksap.tistory.com/1148?category=755546)

  1. 웹 브라우저가 `https://www.google.com/images/google.png` 로 이미지를 요청 해야 한 다는 것을 인지 한다.
  2. 웹 브라우저는 url을 이용해 서버의 ip를 추출한다. 
  3. 이미지를 요청하기 위한 HTTP 메세지를 만든다.
  4. 메세지는 get메서드이고 /google.png를 요청하는 메세지이다.
  5. 웹브라우저는 서버와 TCP 컨넥션을 맺는다.
  6. 웹브라우저는 서버에 HTTP요청을 보낸다.
  7. 서버는 메세지를 받고 무슨 내용인지 해석한다. get이라는 메서드이고 /google.png라는 파일을 요청 했다는 것을 인지한다.
  8. 서버는 해당 리소스가 있는지 찾는다.
  9. 찾으면 상태코드가 200인 메세지와 함께 응답 메세지를 작성한다.
  10. 서버는 클라이언트와 TCP컨넥션을 맺는다.
  11. 서버는 클라이언트에 HTTP 응답을 보낸다.
  12. 커넥션이 닫히면 웹브라우저는 사용자에게 이미지를 보여준다.


  </details>

- 웹 서버 소프트웨어(Apache, Nginx)는 OSI 7계층 중 어디서 작동하는지 설명해보세요.
  <details>

  | 정답이 없던 질문지를 가져온것이라, ChatGPT 피셜입니다. 근거와 자료는 조금 더 찾아보고 추가 부탁드립니다 :)  -> 저도 서버 공부하고 보강하여 추가해놓을게요!! 

  - 5계층과 7계층
  - 세션 계층(Session Layer)
      - 통신 세션의 설정 및 유지를 담당
      - 웹 서버는 클라이언트와의 통신 세션을 관리하고 필요한 경우 세션을 설정하거나 종료하는 역할
      - 웹 서버는 클라이언트의 요청을 받아들이고 응답을 전송하는 과정에서 세션 계층의 기능을 활용
  - 응용 계층(Application Layer)
      - 사용자와 직접 상호작용하는 애플리케이션을 지원합니다. 웹 서버는 HTTP(Hypertext Transfer Protocol)를 통해 웹 페이지를 제공하는 역할
      - 웹 서버는 클라이언트로부터의 HTTP 요청을 받아들이고, 요청된 내용에 따라 적절한 응답을 생성하여 클라이언트에게 반환
  - Apache와 Nginx는 5계층의 세션 계층에서 통신 세션 관리를 수행하고, 7계층의 응용 계층에서 HTTP 프로토콜을 기반으로 웹 페이지를 제공하는 역할
  </details>

- 웹 서버 소프트웨어(Apache, Nginx)의 서버 간 라우팅 기능은 OSI 7계층 중 어디서 작동하는지 설명해보세요.

  <details>

  - 4계층
  - 전송 계층(Transport Layer)
      - 호스트 간의 통신을 제어하고 데이터의 신뢰성과 효율성을 담당
      - **웹 서버의 라우팅 기능은 주로 전송 계층의 기능을 활용하여 동작**
      - Apache와 Nginx는 라우팅 기능을 통해 클라이언트의 요청을 다른 서버로 전달하는 역할을 수행
      - 이를 위해 주로 프록시 서버(proxy server)라는 개념을 사용
          - 프록시 서버는 클라이언트와 웹 서버 사이에서 중개자 역할을 수행
      - 클라이언트의 요청을 받아들인 후에 해당 요청을 적절한 웹 서버로 전달
      - 라우팅 기능은 전송 계층에서 동작하기 때문에, TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol) 같은 전송 계층 프로토콜을 사용하여 서버 간의 통신을 관리
      - 프록시 서버는 클라이언트로부터의 요청을 받을 때, 목적지 서버의 IP 주소와 포트 번호를 설정하여 해당 서버로 전달
      - 4계층의 전송 계층에서 작동하여 클라이언트의 요청을 적절한 서버로 전달
  </details>


- 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다
  <details>

  - 데이터링크 계층 - 프레임
  - 네트워크 계층 - 패킷
  - 전송계층 - 세그먼트
  </details>

- **www.naver.com 에 접속하는 과정에 대해 설명해주세요.** 

  <details>
  1. 사용자가 브라우저에 URL을 입력<br>
  2. DNS 서버에 도메인 네임으로 서버의 진짜 주소를 찾음<br>
  3. IP 주소로 웹 서버에 TCP 3 handshake로 연결 수립<br>
  4. 클라이언트는 웹 서버로 HTTP 요청 메세지를 보냄<br>
  5. 웹 서버는 http 응답 메세지를 보냄<br>
  6. 도착한 HTTP 응답 메세지는 웹 페이지 데이터로 변환되고, 웹 브라우저에 의해 출력<br>
  </details>

- 도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해 주세요.

  <details>

  Recursive Query를 통해 접근 : Local DNS 서버 -> Root DNS 서버 -> com DNS 서버 -> naver.com DNS 서버

  1. 로컬 DNS서버에 해당 url이 등록되어있는지 확인
  2. 루트 DNS서버에 문의 후 최상위 도메인 .com이 등록된 네임 서버의 IP주소 전달
  3. 로컬 DNS서버는 com DNS 서버에 해당 url을 문의함. 로컬 DNS서버에 naver.com DNS 서버의 IP 주소 알려줌
  4. naver..com에 해당 url 문의함. 로컬 DNS는 IP 주소를 받을수있음

  </detals>


- hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?
  <details>

  [참고 블로그](https://change-words.tistory.com/entry/DNS-hosts)

  - hosts 파일은 로컬호스트용 DNS 입니다.
  - 도메인을 요청하고, DNS 서버로 가기 전 들르는 곳이 바로 hosts 파일
  - hosts 파일에 매핑한 IP 주소와 도메인은 DNS 서버보다 우선한다.
  
    ```
    구글 IP 주소 = 172.217.26.238
    만약 hosts 파일에 172.217.26.238 라는 IP를 www.naver.com으로 매핑하면 ??
    - 내 컴퓨터에서는 www.naver.com으로 url 요청을 해도, 웹 브라우저는 구글 홈페이지를 찾아간다.
    ```
  </details>


- DNS Recursive Query, Iterative Query가 무엇인가요?
  <details>

  [참고 블로그 - DNS 란 무엇인가, 재귀적, 반복적 커리](https://hihighlinux.tistory.com/47)
  [참고 블로그 - DNS](https://securitymax.tistory.com/103)

  - Recursive Query
    - Local DNS 서버가 여러 DNS 서버를 차례대로 물어봐서, 그 답을 찾는 과정 -> 재귀적 질의

  - Iterative Query
    - Local DNS 서버가 다른 DNS 서버에게 쿼리를 보내어 답을 요청하는 작업
    - 자신이 직접 관리하지 않는 질의 요청이 있을 경우 질의에 응답 가능한 NS 목록을 응답한다.
    - 예를 들어, 컴퓨터가 질의한 것이 `www.naver.com` 이라 하면 자신은 com 도메인이고, 자신의 하위 도메인에 naver.com이 있을 때, 컴퓨터에 naver.com을 관리하는 DNS를 알려주는 것

  </details>

- DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
  <details>
  
  | GPT 피셜이므로, 디테일한 DNS 원리는 공부해야 할 것 같습니다 !  

  1. 다른 DNS 서버 시도
    - 클라이언트는 DNS 계층의 장애 복구 메커니즘을 활용하여, 여러 DNS 서버에 연결을 시도할 수 있다.
    - DNS 서버에 연결하기 전에 여러 서버 주소를 확인하고, 이중화된 DNS 서버 구성을 사용하여, 장애 발생 시 다른 서버로 쿼리를 보낼 수 잇다.
  2. 캐시활용
    - DNS 서버는 응답을 캐시에 저장하여, 동일한 쿼리에 대한 반복적인 요청 처리 
    - 따라서, 손실이 발생하더라도, 캐시에 해당 쿼리의 응답이 있을 수 있다.
    - 클라이언트는 캐시된 응답을 확인하고 사용할 수 있다. 
    - 이를 통해 응답을 다시 요청하지 않고도 쿼리 결과를 얻을 수 있다
  3. 타임아웃 설정
    - 클라이언트와 DNS 서버 간의 통신은 일정 시간 내에 완료되어야 함
    - 클라이언트는 DNS 쿼리에 대한 응답을 기다리는 시간에 대한 타임아웃 값을 설정
    - 손실이 발생하면, 타임아웃이 발생하여, 클라이언트는 더 이상 대기하지 않고, 다른 조치를 취할 수 있다.
  4. 네트워크 문제 해결 & 에러 핸들링
  </details>

- DHCP의 정의
  <details>

  [참고자료](https://nordvpn.com/ko/blog/what-is-dhcp/)

  - ‘Dynamic Host Configuration Protocol(동적 호스트 구성 프로토콜)’의 약자로, IP 네트워크에 사용되는 네트워크 프로토콜

  - DHCP는 IP 주소 및 기타 통신 매개변수를 네트워크에 연결된 장치에 자동으로 할당합니다. 대부분의 가정용 네트워크에서는 라우터가 IP 주소를 장치에 할당하는 DHCP 서버의 역할
  </details>

- DHCP는 몇 계층 프로토콜인가요?
  <details>

  [참고자료](https://nordvpn.com/ko/blog/what-is-dhcp/)

  DHCP (Dynamic Host Configuration Protocol)는 OSI (Open Systems Interconnection) 7계층 모델에서 **네트워크 계층인 제3 계층 프로토콜**입니다. 

  DHCP는 IP 주소 할당, 서브넷 마스크, 기본 게이트웨이, DNS (Domain Name System) 서버 등과 같은 네트워크 구성 정보를 동적으로 클라이언트에게 제공하기 위해 사용됩니다. 따라서, DHCP는 네트워크 계층에서 IP 주소 관리와 구성을 담당하는 프로토콜
  </details>

- **subnet이란?**

  <details>

  IP 네트워크의 작은 부분으로, 주어진 IP를 더 작은 네트워크로 분할하는 기술적인 개념이다. 네트워크 관리와 주소 할당을 효율적으로 수행하고, 트래픽을 분리하거나 보안을 강화하기 위해 사용된다.<br>
  서브넷은 IP 주소와 서브넷 마스크(Subnet Mask)를 사용하여 정의됩니다. 서브넷 마스크는 IP 주소의 네트워크 부분과 호스트 부분을 구분하는 역할을 합니다.
  서브넷은 IP 주소 공간을 여러 개의 작은 네트워크로 분할하여, 네트워크 관리를 용이하게 합니다.
  </details>

- **TLD(Top-Level Domain)란?**

  <details>
  인터넷 도메인 이름 시스템에서 가장 높은 수준의 도메인을 나타내는 부분입니다.<br>
  <br>
  TLD는 도메인 이름의 의미를 나타내기도 하며, 도메인을 관리하는 조직, 지리적 위치, 용도 등에 따라 다양한 종류가 있다.<br>

  일반적으로 TLD는 두 가지 유형으로 분류된다.<br>
  1. Generic Top-Level Domains(gTLDs): 대부분의 일반적인 목적으로 사용되는 도메인을 나타낸다. 예를 들어, “.com”(상업적인 사이트), “.org”(비영리 단체), “.net”(네트워크), “.edu”(교육기관), “.gov”(정부기관) 등이 gTLDs의 예이다.<br>
  2. Country Code Top-Level Domains(ccTLDs): 각 나라 또는 특정 지역을 나타내는 도메인을 나타낸다. 이러한 도메인은 국가 코드로 식별되며, 예를 들어 “.kr” (대한민국), “.uk”(영국), “.jp”(일본)등이 ccTLD의 예이다.<br>
  </details>
 
 - **IPv4 vs IPv6**

      <details>
      IPv4와 IPv6는 인터넷 프로토콜(IP) 주소 체계의 버전을 나타내는 것입니다.<br>
    <br>
      IPv4 (Internet Protocol version 4): <br>
    <br>
      - IPv4는 현재까지 가장 널리 사용되는 인터넷 프로토콜 버전입니다. <br>
      - IPv4 주소는 32비트로 구성되어 있으며, 주소 공간은 약 43억개의 고유한 주소를 지원합니다. <br>
      - IPv4 주소는 일반적으로 네 개의 10진수로 표시되며, 예를 들면 "192.168.0.1"과 같이 구성됩니다. <br>
      - 그러나 인터넷의 성장과 장치들의 증가로 인해 IPv4 주소 공간의 고갈 문제가 발생했습니다. <br>
    <br>
      IPv6 (Internet Protocol version 6): <br>
    <br>
      - IPv6는 IPv4 주소 고갈 문제를 해결하기 위해 개발된 다음 세대 인터넷 프로토콜 버전입니다. <br>
      - IPv6 주소는 128비트로 구성되어 있으며, 주소 공간은 약 340 십경개(약 3.4×10^38)의 고유한 주소를 지원합니다. <br>
      - IPv6 주소는 16진수로 표시되며, 예를 들면 "2001:0db8:85a3:0000:0000:8a2e:0370:7334"과 같이 구성됩니다. <br>
      - IPv6는 보안, 품질 보증(QoS), 자동 구성 등의 기능을 개선하고, 인터넷에 연결된 장치들의 수용량을 크게 확장합니다. <br>
    <br>
      IPv4와 IPv6는 서로 다른 주소 체계를 사용하기 때문에 호환성 문제가 발생할 수 있습니다. 따라서 현재는 IPv4와 IPv6를 함께 사용하고 있으며, 이를 "Dual Stack"이라고 부르는 방식으로 호환성을 유지하며 전환 작업이 진행되고 있습니다.
      </details>
      
  - **세션 기반 인증과 토큰 기반 인증의 차이에 대해 얘기해주세요.**

    <details>
     세션 기반 인증은 클라이언트로부터 요청을 받으면 클라이언트의 상태 정보를 저장하므로 Stateful한 구조를 가지고,

    토큰 기반 인증은 상태 정보를 서버에 저장하지 않으므로 Stateless한 구조를 가집니다.

    ****💡 그렇다면 Stateful한 세션 기반의 인증 방식을 사용하게 된다면 어떠한 단점이 있을까요?****

    1. 서버에 세션을 저장하기 때문에 사용자가 증가하면 서버에 과부하를 줄 수 있어 확장성이 낮습니다.
    2. 해커가 훔친 쿠키를 이용해 요청을 보내면 서버는 올바른 사용자가 보낸 요청인지 알 수 없습니다. (세션 하이재킹 공격)

    ****💡 그렇다면 세션 기반 인증과 토큰 기반 인증은 각각 어느 경우에 적합한가요?****

    단일 도메인이라면 세션 기반 인증을 사용하고, 아니라면 토큰 기반 인증을 사용하는 것이 적합하다고 생각합니다.

    왜? - 세션을 관리할 때 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있기 때문에 여러 도메인에서 관리하는 것은 어렵습니다. (CORS 문제)
     </details>
    
   - **JWT가 무엇인가?**
      <details>
        JWT는 JSON 포맷을 이용하는 Claim 기반의 웹 토큰이며, 토큰 자체를 정보로 사용하는 Self-Contained 방식으로 정보를 안전하게 전달합니다.

        JWT는 헤더(Header).내용(Payload).서명(Signature)로 구성되며 각 파트를 점(.)으로 구분합니다.

        **헤더(Header) :**

        토큰의 타입과 해시 암호화 알고리즘(방식지정)으로 이루어져 있다.

        **내용(Payload) :**

        토큰에 사용자가 담고자 하는 정보를 담는다. 내용에는 Claim이 담겨있고, JSON(Key/Value)형태의 한 쌍으로 이루어져 있다.

        **서명(Signature) :**

        토큰을 인코딩하거나 유효성 검증할 때 사용하는 고유한 암호화 코드이다. 헤더와 내용의 값을 인코딩한다.
      </details>

  - **Cookie가 무엇이고, 어디에 많이 사용되는가?**
      <details>
        쿠키(Cookie)는 웹 애플리케이션에서 클라이언트(일반적으로 웹 브라우저)에 저장되는 작은 데이터 조각입니다. 쿠키는 웹 사이트가 클라이언트의 컴퓨터에 정보를 저장하고 검색할 수 있는 방법을 제공하여 사용자와 상호작용하고 상태를 유지하는 데 사용됩니다. 주로 다음과 같은 목적으로 사용됩니다.<br>
        세션 관리, 개인화, 사용자 추적 및 분석, 광고 타켓딩에 사용된다. 하지만, 쿠키는 보안과 개인 정보 보호 측면에서 주의해야 한다.
      </details>
      
  - **TCP와 IP의 차이는?**
      <details>
        - IP주소 체계를 따른다. (네트워크 계층 layer 3) <br>
        - TCP 특성을 활용해 송수신자의 논리적 연결을 생성하고, 신뢰성을 유지할 수 있도록 하겠다.(전송계층 layer4) <br>
        - 정확히 말하자면 TCP가 올바른 통신을 하도록 도와주는 기능을 가지고 있으며, IP는 이러한 기능없이 오로지 TCP 패킷을 전송하는 일만을 한다.
      </details>
------

### 3 way - 4 way handshake

- 올바른 통신을 하기 위해 TCP가 갖는 기능은?
  <details>
  1. 패킷이 빠졌을경우, 재전송을 요청하는 기능
  2. 패킷에 일련번호를 줌으로써, 서로 다르게 도착될지도 모르는 패킷의 순서를 재조합하는 기능
  </details>

- TCP와 UDP의 차이에 대해서 설명해 주세요.

  <details>
    **TCP**

    - 신뢰성 있는 데이터 전송을 지원하는 연결 지향형 프로토콜
    - 흐름제어, 혼잡제어, 오류제어 지원
    - 연결 설정시 3 way handshake를, 연결 해제시 4 way handshake 진행
    - UDP보다 속도가 느리다
    - **EX)** 웹 http 통신, 이메일, 파일 전송

    **UDP**

    - 데이터를 데이터그램 단위로 처리하는 프로토콜
    - 신뢰성 낮음
    - 속도가 빠르고 부하가 적다
    - **EX)** Real Time Protocol(RTP), Multicast, DNS
  </details>


- **3 way-handshake와 4 way-handshake를 설명해주세요**

  <details>

  3 way-handshake란 TCP 네트워크에서 통신 하는 장치가 서로 연결이 잘 되었는지 확인하는 방법입니다. 송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신이 가능한 상태인지 확인한다.<br>
  <br>
  4 way-handshake란 TCP 네트워크에서 통신하는 장치의 연결을 해제하는 방법이다. 송신자와 수신자는 총 4번에 걸쳐 데이터를 주고 받으며 연결을 끊는다.
  </details>
  

- TCP 패킷이 3 ways handshake를 했는지 안했는지는 어떻게 저장하고 있지?

  <details>

  TCP 세그먼트 헤드에 flag 값이 비트로 저장, 이걸로 현재 클라이언트 서버와 연결했는지 확인합니다
  </details>

- IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?
  
  <details>

  - IPv4 체크섬은 IP 패킷 헤더의 무결성을 확인하는 데 사용되며, TCP 체크섬은 TCP 세그먼트의 무결성을 확인하는 데 사용됩니다.
  - IPv4 체크섬은 각 라우터를 통과할 때마다 다시 계산되고 갱신될 수 있습니다. 반면에 TCP 체크섬은 출발지 호스트에서 목적지 호스트까지의 통신 동안 동일한 값을 유지합니다.

  1. IPv4 체크섬:
      - IPv4 패킷 헤더의 무결성을 확인하기 위해 사용됩니다.
      - IPv4 패킷 헤더에 포함된 필드들의 비트를 조합하여 체크섬 값을 계산합니다.
      - 송신자는 패킷을 보내기 전에 IPv4 체크섬을 계산하고, 수신자는 패킷을 받은 후 체크섬을 다시 계산하여 송신자가 계산한 값과 일치하는지 확인합니다.
      - 체크섬 오류가 발견되면 패킷은 손상되었다고 간주되고 폐기됩니다.

  2. TCP 체크섬:
      - TCP 세그먼트의 무결성을 확인하기 위해 사용됩니다.
      - TCP 세그먼트에 포함된 데이터와 헤더의 비트를 조합하여 체크섬 값을 계산합니다.
      - 송신자는 TCP 세그먼트를 보내기 전에 TCP 체크섬을 계산하고, 수신자는 세그먼트를 받은 후 체크섬을 다시 계산하여 송신자가 계산한 값과 일치하는지 확인합니다.
      - 체크섬 오류가 발견되면 세그먼트는 손상되었다고 간주되고 폐기됩니다.


  </details>

- 만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까요?

  <details>

  이러한 현상에 대비하여 Client는 Server로부터 FIN 플래그를 수신하더라도 일정시간(Default: 240sec)동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)
  </details>


- TCP의 연결 성립 과정(3-way handshake)과 연결 해제 과정(4-way handshake)의 단계수가 차이 나는 이유는?

  <details>

  Client가 데이터 전송을 마쳤다고 해도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후 자신도 FIN메세지를 보내기 때문이다.
  </details>

- 초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유는?
  
  <details>

  - Connection을 맺을 때 사용하는 포트(Port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 
  - 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 
  - Server측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 Number가 전송된다면 이전의 Connection으로부터 오는 패킷으로 인식할 수 있다. 
  - 이런 문제의 발생 가능성을 낮추기 위해 ISN을 난수로 설정한다.
  </details>

- TCP 의 3way handshake의 취약점을 이용해 서버를 공격하는 방법으로 SYN Flooding이라는 기술이 있다. 해당 DDOS 방법에 대해 아는가?
  
  <details>

  악의적인 공격자가 실제로 존재하지 않는 클라이언트 IP로 응답이 없는 연결을 초기화 하기 전에 또 새로운 연결 즉, 1단계 요청만 무수히 많이 보내어, 백로그 큐를 포화 상태로 만들어 다른 사용자로부터 더이상에 연결 요청을 못받게 하는 기법

  클라이언트가 SYN(1번) 패킷만 계속적으로 보내고 ACK(3번) 패킷을 안보내게 되면, 서버는 클라이언트의 연결을 받아들이기 위해 RAM(메모리) 공간을 점점 더 많이 확보 해둔 상태에서 대기한다.

  </details>

- SYN Flooding 문제가 발생한다면 어떤 대응책이 있을 것 같은지? 모른다면 생각해봐도 된다!

  <details>

  1. 백로그 큐의 크기를 늘린다. (완벽한 방어방법은 아니지만, 임시로 접속 문제 해결 가능)
  2. SYN Cookie를 설정한다.
    - 이 설정을 하게 되면, 클라이언트로부터 ACK를 받을 때까지 Backlog Queue에 요청 정보를 저장하지 않는다
    - 쿠키라는 것을 이용하여, 전체 연결이 설정되기 전 까지는 자원의 할당을 연기하는 방법
  3. 방화벽의 동일 클라이언트 IP에 대해 연결요청(SYN) 임계치를 설정한다.
  4. TCP 연결 과정 대기 시간을 줄인다
  </details>

- 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?

  <details>

  1. RST (Reset) 패킷 전송:
    - TCP 연결을 강제로 종료하기 위해 송신자 또는 수신자는 RST 패킷을 전송할 수 있습니다.
    - RST 패킷은 연결을 즉시 종료하고, 상대방에게 연결이 예기치 않게 끊겼음을 알리는 역할을 합니다.
    - RST 패킷은 일반적으로 네트워크 장애 또는 보안 문제와 같은 이유로 사용됩니다.

  2. 타임아웃 설정:
      - TCP 연결을 종료하기 위해 4-way Handshake 과정을 거치지 않고 타임아웃을 설정할 수 있습니다.
      - 일반적으로 TCP 연결은 ACK 패킷을 교환하고 일정 시간동안 대기한 후 종료합니다. 이 대기 시간을 단축하여 빠른 연결 종료를 수행할 수 있습니다.
      - 단, 이 방법은 예기치 않은 종료로 인해 데이터의 손실이 발생할 수 있으므로 주의해야 합니다.


  TCP 연결을 빠르게 종료하는 방법 중 일부입니다. 그러나 이러한 방법은 일반적인 TCP 연결 종료 프로세스를 우회하는 것이므로 주의가 필요합니다. TCP 연결 종료는 데이터의 신뢰성과 무결성을 보장하기 위한 중요한 과정이므로, 특수한 상황이 아니라면 4-way Handshake를 정상적으로 수행하는 것이 좋습니다.

  </details>

- 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?

  <details>

  1. 타임아웃 (Timeout) 발생
    - TCP 연결 종료 과정에서 각 단계에는 타임아웃이 설정됩니다. 예를 들어, FIN 패킷을 보낸 후 ACK를 기다리는 동안 타임아웃이 발생할 수 있습니다.
    - 한쪽 네트워크가 강제로 종료되었다면, 반대쪽은 해당 단계에서 타임아웃을 감지하고 타임아웃 이벤트를 처리합니다.
    - 타임아웃이 발생하면 반대쪽은 종료 과정을 진행하지 못한 쪽의 상태를 알 수 있습니다.

  2. 재전송 타이머 (Retransmission Timer) 만료
    - 4-Way Handshake 과정에서 각 단계에서는 재전송 타이머가 설정됩니다. 이 타이머는 ACK를 수신하지 못한 경우 해당 패킷을 재전송하기 위해 사용됩니다.
    - 한쪽 네트워크가 강제로 종료되었다면, ACK 패킷이 상대쪽으로 전달되지 않을 것입니다. 이로 인해 재전송 타이머가 만료되고, 반대쪽은 해당 패킷의 전송 실패를 인식

  3. 상태 확인 (Keep-Alive)
    - TCP 연결 종료 과정에서 Keep-Alive 메커니즘을 사용할 수 있습니다. 
    - 연결이 유지되는 동안 주기적으로 상태 확인 메시지를 교환하여 상대쪽의 응답을 확인하는 역할
    - 한쪽 네트워크가 강제로 종료되었다면, Keep-Alive 메시지에 대한 응답이 없을 것입니다. 이로 인해 상대쪽은 연결이 끊어진 것을 인식하고 적절한 조치를 취할 수 있다.

  </details>


- TCP 통신에서 지연 패킷이 발생했을 때 서버는 이것을 어떻게 처리하나요?
  <details>
  
  - 재전송 타이머
  - 선택적 재전송
  - 흐름제어
  - 혼잡제어
  </details>

------

### 혼잡제어 & 흐름제어 & UDP


- **TCP 와 UDP을 설명해주세요 <br>-> TCP 기능인 흐름제어와 혼잡제어에 대해 설명해주세요 <br>-> 혼잡제어 기법 중 AIMD 방식이 있는데 설명하세요. 또한, 문제점도 설명해주세요.**

  <details>
  [TCP와 UDP에 대해 설명해주세요]<br>
  TCP는 연속성보다 신뢰성 있는 전송이 중요할 때 사용되는 프로토콜이며, UDP는 TCP보다 빠르고 네트워크 부하가 적다는 장점이 있지만, 신뢰성 있는 데이터 전송을 보장하지는 않는다. 그렇기 때문에 신뢰성보다는 연속성이 중요한 실시간 스트리밍과 같은 서비스에 자주 사용된다.<br>
  <br>
  [TCP 기능인 흐름제어와 혼잡제어에 대해 설명해주세요] <br>
  흐름제어는 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법, 흐름제어는 수신측이 packet을 지나치게 많이 받지 않도록 조절하는 것, 수신측은 송신측에게 현재 자신의 상태를 피드백 한다는 점<br>
  혼잡제어는 송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법 <br>
  <br>
  [혼잡제어 기법 중 AIMD 방식이 있는데 설명하세요. 또한, 문제점도 설명해주세요]<br>
    AIMD(Additive Increase / Multiplicative Decrease) <br>
  - 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법 <br>
  - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다. <br>
  - 공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 되는 특징이 있다. <br>
  - 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.
  </details>

- DNS에서 UDP를 사용하는 이유?
  <details>
  Request의 양이 작다 → UDP Request에 담길 수 있다. 
  <br>
  1. 3 way handshake로 연결을 유지할 필요가 없다. 
  2. Request에 대한 손실은 Application Layer에서 제어가 가능하다. 
  3. DNS : port 53번 - 그렇지만 크기가 512(UDP 제한)을 넘기면, TCP를 사용해야 한다.

  </details>

- UDP의 체크섬은 무엇인가요?
  <details>
  세그먼트가 출발지로부터 목적지로 이동했을 때, **UDP 세그먼트 안의 비트에 대한 변경사항이 있는지 검사**하여 오류 검출을 하기 위한 것이다.
  <br>
  1. 송신자 측에서 세그먼트 안에 있는 **모든 16비트 워드의 합산에 대해 다시 1의 보수를 수행**하며, 합산 과정에 발생하는 오버플로는 윤회식 자리올림(wrap around)을 한다.
  2. 이 결괏값이 UDP 세그먼트의 체크섬 필드에 삽입된다.
  3. 수신자에서는 **체크섬을 포함한 모든 16비트 워드들이 더해진다.**
  4. 만약 패킷에 어떤 오류도 없다면 수신자에서의 합은 `1111111111111111`이 되며, 비트 중에 `0이 하나라도 있다면` 패킷에 오류가 발생했다는 것이다.
  </details>

- UDP는 왜 체크섬을 제공하나요?
  <details>

  - 출발지와 목적지 사이의 모든 링크가 오류 검사를 제공한다는 보장이 없기 때문이다.
  - 따라서 세그먼트들이 정확하게 링크를 통해 전송되었을지라도, 세그먼트가 라우터의 메모리에 저장될 때 비트 오류가 발생할 수가 있다.
  - UDP는 오류 검사를 제공하지만, 오류를 회복하기 위한 어떤 일도 하지 않는다.
  - 손상된 세그먼트를 그냥 버리기도 하고, 경고와 함께 손상된 세그먼트를 애플리케이션에게 넘겨주기도 한다.
  </details>


------
### 참고한 CS 질문 레포

- [tech_interview.zip](https://github.com/4z7l/tech_interview.zip) - 네트워크 
- [Fancy96_2023_CS_study](https://github.com/Fancy96/2023-CS-Study/blob/main/Interview/network_expected_question.md)
- [VSFe-Tech_interview](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md)

### 정리 링크

- [세정 질문 준비](https://evening-november-9ec.notion.site/19-03b95d592b804d97b38f49621856ebed)
