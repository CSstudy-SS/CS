### 공부 주제 (복습 + 추가)

- 인덱스
- 트랜잭션
- 트랜잭션 격리 수준
- 저장 프로시저
- 레디스


## 질문

- Index를 쓰는 이유

    <details>
    <br>
    조건을 만족하는 튜플을 빠르게 조회하기 위해서 

    빠르게 정렬하거나 그룹핑 하기 위해서

    **단점은?**

    - Index 생성시, .mdb 파일 크기가 증가한다.
    - 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
    - 인덱스 된 Field에서 Data를 업데이트하거나, Record를 추가 또는 삭제시 성능이 떨어진다.
    - 데이터 변경 작업이 자주 일어나는 경우, Index를 재작성해야 하므로 성능에 영향을 미친다.
    
    <br>
    
    **사용하면 좋은 상황은?**

    - Where 절에서 자주 사용되는 Column
    - 외래키가 사용되는 Column
    - Join에 자주 사용되는 Column
    
    <br>
    
    **Index 사용을 피해야 하는 경우는?**

    - Data 중복도가 높은 Column
    - DML이 자주 일어나는 Column → **왜 그런가? (데이터를 수정하면 그 시간동안 다른 작업을 처리하지 못해서 성능에 안좋은 영향을 미친다)**
    </details>

- covering index란?  -> clustering index이랑 차이점은?

    <details>
    <br>
    조회하는 특성들의 index가 모두 cover할 때

    ex) select col1, col2 from test_table;

    <br>
    
    **실무에서 종종 사용한다는데 왜 사용하는가?**

    조회 성능이 더 빠름
    
    <br>
    
    **단점은?**

    인덱스 크기가 증가하고 추가 디스크 공간이 필요할 수 있다.
    </details>


- Index 데이터 구조 중에서 B-tree구조 이외의 다른 구조에 대해 아는가?

    <details>

    Hash Index, Bitmap Index, R-tree, GIST Index
    </details>

- Index를 사용하여 탐색하는 것 보다 Full scan탐색이 더 좋은 경우가 있는가?

    <details>

    table에 데이터가 조금 있을 때
    <br>
    조회하려는 데이터가 테이블의 상당 부분을 차지할 때
    <br>
    cf) full scan할 지 여부는 optimizer가 판단
    </details>

- 이진 탐색 트리란?

    <details>

    하나의 부모가 두 개의 자식만 가진 트리
    
    <br>
    
    **단점은?**    

    균형이 맞지 않으면 검색 효율이 선형검색O(N) 급으로 떨어진다.
    
    <br>
    
    **그러면 B-tree와의 차이점은?**

    이진 트리를 확장해서, 더 많은 수의 자식을 가질 수 있게 일반화 시킨 것이 B-tree
    <br>
    자식 수에 대한 일반화를 진행하면서, 하나의 레벨에 더 저장되는 것 뿐만 아니라 트리의 균형을 자동으로 맞춰주는 로직까지 갖추었다. 단순하고 효율적이며, 레벨로만 따지면 완전히 균형을 맞춘 트리이다.

    </details>


- 트랜잭션이란?

    <details>
    데이터 베이스의 상태를 변화시키기 위해 수행하는 작업 단위
    <br>
    <br>
    
    **트랜잭션 특징 4가지가 무엇인가?**

    원자성: 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
    <br>
    일관성: 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
    <br>
    독립성: 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
    <br>
    지속성: 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.
    </details>


- Lock-based protocol이 무엇인가

    <details>

    데이터베이스 관리 시스템에서 잠금 기반 프로토콜은 데이터 테이블, 인덱스 및 기타 데이터 구조와 같은 공유 리소스에 액세스하는 트랜잭션의 일관성 및 격리성를 보장하는 데 사용되는 동시성 제어 메커니즘입니다.
    <br>
    <br>
    **Long-term locking 과 short-term locking의 차이점은?**

    Long-term은 일관성을 예방하고, 동시성 레벨을 낮춘다.

    short-term은 동시성 레벨을 높이나 일관성을 해칠수 있다.
    <br>
    <br>
    **Lock-based protocol의 문제점 중에 기아 현상이라고 있는데 아는가?**

    데이터 베이스에서 기아 상태는 트랜잭션 또는 쿼리가 실행에 필요한 리소스를 사용할 수 있음에도 불구하고 다른 트랜잭션 또는 쿼리에 의해 독점되어 해당 리소스를 획득할 수 없는 상황을 말합니다.
    <br>
    <br>
    **어떻게 방지할까?**

    기아 상태를 방지하기 위해 데이터베이스는 종종 모든 트랜잭션과 쿼리에 리소스에 대한 공정한 액세스 권한이 부여되고 어떤 트랜잭션이나 쿼리도 리소스를 무한정 독점할 수 없도록 하는 스케줄링 알고리즘을 사용합니다. 여기에는 모든 트랜잭션과 쿼리가 리소스가 고갈되지 않고 적시에 완료될 수 있도록 우선 순위 대기열, 리소스 선점 및 시간 초과 메커니즘과 같은 기술을 사용하는 것이 포함될 수 있습니다.
    </details>

- 낙관적인 락에대해 아는가?
    <details>

    낙관적 락은 DB 충돌 상황을 개선할 수 있는 방법 중 2번째인 수정할 때 내가 먼저 이 값을 수정했다고 명시하여 다른 사람이 동일한 조건으로 값을 수정할 수 없게 하는 것이다. 이 특징은 DB에서 제공해주는 특징을 이용하는 것이 아닌 Application level에서 잡아주는 lock이다.
    <br>
    쉽게 말하면, 자원에 락을 걸어서 선점하지말고, 동시성 문제가 발생하면 그때 가서 처리하자는 방법론입니다.
    </details>

- 프로시저란?
    <details>

    일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
    <br>
    
    **장점은?**

    1. 최적화 & 캐시: 프로시저의 최초 실행 시 최적화 상태로 컴파일이 되며, 그 이후 프로시저 캐시에 저장된다. 만약 해당 프로세스가 여러번 사용될 때, 다시 컴파일 작업을 거치지 않고 캐시에서 가져오게 된다.
    2. 유지 보수: 작업이 변경될 때, 다른 작업은 건드리지 않고 프로시저 내부에서 수정만 하면 된다.
    3. 트래픽 감소: 클라이언트가 직접 sql문을 작성하지 않고, 프로시저명에 매개변수만 담아 전달하면 된다. 즉, SQL문이 서버에 이미 저장되어 있기 때문에 클라이언트와 서바간 네트워크 상 트래픽이 감소한다.
    4. 보안: 프로시저 내에서 참조 중인 테이블의 접근을 막을 수 있다.
    <br>
    
    **단점은?**

    1. 호환성
    2. 성능: 문자 또는 숫자 연산에서 프로그래밍 언어인 c나 JAVA보다 성능이 느리다.
    3. 디버깅: 에러가 발생했을 때, 어디서 잘못됐는지 디버깅하는 것이 힘들 수 있다.
    </details>


- 프로시저 VS 트리거
    <details>

    **프로시저**

    저장 프로시저는 미리 데이터 베이스 서버에 일련의 SQL 명령을 해놓고, 프로시저를 실행하여 SQL 명령을 간단하게 실행할 수 있도록 할 수 있다. 프로시저 안에는 SQL 문장뿐만 아니라 if, while문 등의 제어 명령이나 반복 명령을 기술할 수 있기 때문에 일종의 프로그램도 만들 수 있다.

    **트리거**

    트리거는 테이블에 작성한다. 어떤 테이블에 행을 삽입한다든지, 행을 변경, 삭제했을 때에 트리거가 설정되어 잇으면 트리거의 SQL 문장이 자동으로 실행된다.
    </details>

- Redis란 무엇인가?
    <details>

    Key, value 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈 소스 기반의 비관계형 데이터 베이스 관리 시스템(DBMS)이다.

    데이터베이스, 캐시, 메세지 브로커로 사용되며 인메모리 데이터 구조를 가진 저장소입니다.
    <br>
    
    **특징은?**

    - Key, Value 구조이기 때문에 쿼리를 사용할 필요가 없습니다.
    - 데이터를 디스크에 쓰는 구조가 아니라 메모리에서 데이터를 처리하기 때문에 속도가 빠릅니다.
    - String, Lists, Sets, Sorted Sets, Hashes 자료 구조를 지원합니다.

        String : 가장 일반적인 key - value 구조의 형태입니다.

        Sets : String의 집합입니다. 여러 개의 값을 하나의 value에 넣을 수 있습니다. 포스트의 태깅 같은 곳에 사용될 수 있습니다.

        Sorted Sets : 중복된 데이터를 담지 않는 Set 구조에 정렬 Sort를 적용한 구조로 랭킹 보드 서버 같은 구현에 사용할 수 있습니다.

        Lists : Array 형식의 데이터 구조입니다. List를 사용하면 처음과 끝에 데이터를 넣고 빼는 건 빠르지만 중간에 데이터를 삽입하거나 삭제하는 것은 어렵습니다.

    - Single Threaded 입니다. 한 번에 하나의 명령만 처리할 수 있습니다. 그렇기 때문에 중간에 처리 시간이 긴 명령어가 들어오면 그 뒤에 명령어들은 모두 앞에 있는 명령어가 처리될 때까지 대기가 필요합니다.(하지만 get, set 명령어의 경우 초당 10만 개 이상 처리할 수 있을 만큼 빠릅니다.)
    <br>
    
    **어디에 많이 사용할까?**

    Redis는 캐싱, 세션 스토리지, 실시간 분석 및 작업 대기열을 비롯한 광범위한 사용 사례에 사용할 수 있습니다. 성능과 확장성 덕분에 빠른 실시간 데이터 액세스가 필요한 애플리케이션에 특히 적합합니다.
    <br>
    
    **Redis 사용시 주의할 점은?**

    - 서버에 장애가 발생했을 경우 그에 대한 운영 플랜이 꼭 필요합니다. 인메모리 데이터 저장소의 특성상, 서버에 장애가 발생했을 경우 데이터 유실이 발생할 수 있기 때문입니다.
    - 메모리 관리가 중요합니다.
    - 싱글 스레드의 특성상, 한 번에 하나의 명령만 처리할 수 있습니다. 처리하는데 시간이 오래 걸리는 요청, 명령은 피해야 합니다.
    </details>

- Redis는 인메모리 구조라 데이터가 RAM에 올라가는데, 이러면 데이터 유실 위험이 있는데 이를 어떻게 해결할까?
    <details>
    백업 과정이 존재한다.

    - snapshot : 특정 지점을 설정하고 디스크에 백업
    - AOF(Append Only File) : 명령(쿼리)들을 저장해두고, 서버가 셧다운되면 재실행해서 다시 만들어 놓는 것
    </details>

### 정리 링크

