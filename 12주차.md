### 공부 주제

- 이상(Anomaly)
- B-Tree & B+Tree
- 인덱스
- 트랜잭션


## 질문

### 이상(Anomaly)
- **데이터베이스 이상이란?**
    
    <details>
    이상이란 릴레이션에서 일부 속성들의 종속이나 데이터의 중복으로 인해 데이터 조작시 불일치가 발생하는 것.<br>
    이를 해결하기 위해 정규화를 한다.
    </details>
    
- **이상의 종류는?**
    
    <details>
    삽입이상 : 자료들을 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 이상<br>
    갱신이상 : 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 이상<br>
    삭제이상 : 어떤 정보를 삭제하면, 유용한 다른 정보까지 삭제되어버리는 이상<br>
    </details>
### B-Tree & B+Tree

- **B-트리란?**
    
    <details>
    이진 트리를 확장해서 많은 자식을 갖을 수 있는 균형 트리<br>
    key들이 항상 오름차순으로 정렬되어 구성<br>
    Branch와 Leaf 노드가 key와 data를 저장
    </details>
    
- **B+트리란?**
    
    <details>
    * B트리를 확장해서 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드를 추가한 트리(리프들이 연결되어 있음)<br>
    * Branch 노드는 key만 저장-하나의 노드에 더 많은 key를 담을 수 있게 되므로 트리의 높이가 B 트리에 비해 더 낮아진다.(cache hit를 높임)<br>
    * Leaf 노드는 Key와 Data를 저장하고 Linked List로 연결되어 있음(검색에 유용)
    </details>
    
- **B+트리는 B-트리의 어떤 문제점을 해결하고자 등장했나요?**
    
    <details>
    B-트리의 순회작업에 대한 문제점. <br>
        풀 스캔 시 B트리는 모든 노드를 확인해야하지만, B+ 트리의 경우 리프노드에 연결된 연결리스트로 선형 탐색이 가능하다.</details>
    
- **그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?**

    <details>
        B Tree의 경우 best case에는 루트에서 끝날수 있지만, B+Tree의 경우 무조건 leaf노드까지 가야한다.</details>

- **MySql InnoDB 자료구조는? **

    <details>
    B+트리<br>


- **기존 B+트리와 InnoDB의 B+트리와의 차이점은 뭘까요?** (꼬리질문)

    <details>
        기존 B+트리는 리프노드가 SingleLinkedList이지만, InnoDB의 리프노드는 DoubleLinkedList있고 자식노드로는 SingbleLinkedList로 연결되어있다.</details>

    ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCbs9b%2FbtqBVf7DVW2%2F8JOOKlHiwkoTsqbvbTt7R1%2Fimg.png)

    참고 : https://zorba91.tistory.com/m/293

- **DB에서 RBT(RedBlack-Tree)를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?** 

    <details>RedBlack-Tree는 무조건 하나의 노드에 하나의 데이터 요소만을 저장하므로 어떠한 요소를 탐색하든 참조 포인터 접근이 필수적이다. <br>
    반면, B-Tree는 하나의 노드에 여러 개의 데이터를 저장하므로 각 노드의 데이터 요소를 탐색할 때 참조 포인터 접근 없이 배열의 성질을 이용하여 빠르게 탐색이 가능하다. <br>
        결론적으로 참조 포인터의 접근 수가 B-Tree가 훨씬 적으므로 B-Tree를 인덱스의 자료 구조로 사용한다.</details>

### 인덱스


-  **인덱스 사용을 피해야 하는 경우를 말해주세요.**

    <details>
        데이터 중복도가 높거나 DML이 자주 일어나는 컬럼일 경우.<br></details>

- **데이터 중복도가 높다는 것의 예시 혹은 낮다는 것의 예시를 들어주세요. **(꼬리질문)
    
    <details>
    예를 들어 성별이라는 컬럼이 있다고 하자. (성별은 남자와 여자만 있다고 가정)<br>
    이때 성별에 인덱스를 걸어 봤자 탐색할 수 있는 값이 2개 밖에 없으므로 하나의 성별이 붙은 데이터를 검색하는 데 재수 없으면 Full Scan을 할 수도 있다.<br>
    또한, 인덱스는 내부적으로 Key, Value의 트리 형태로 데이터를 저장하는데, Key가 중복되어 여러 개 존재하면 검색할 대상이 증가한다.<br>
    이러한 이유로 데이터의 중복도가 낮아서 분포도가 높은 컬럼에 대해 인덱스를 사용해야 한다.
    </details>
    
- **DELETE와 UPDATE 연산이 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해지는 이유는?**
    
    <details>
        UPDATE와 DELETE는 기존 인덱스를 삭제하지 않고, '사용하지 않음' 처리를 한다.<br>
    만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생한다면 실제 데이터는 10만 건이지만, 
    인덱스는 100만 건이 넘어가게 되어 SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 되는 것이다.
    </details>
    
- **인덱스의 분류?**
    
    <details>
     클러스터 인덱스 - 테이블의 기본 키 (PK)에 대해 적용되는 인덱스<br>
    비클러스터 인덱스 - 테이블의 기본 키 외에 다른 컬럼에 적용된 인덱스<br>
    유니크 인덱스<br>
    -테이블의 기본 키는 아니지만, 중복을 허용하지 않는 Unique 속성이 들어간 컬럼에 적용된 인덱스<br>
    -참고로 클러스터 인덱스는 유니크 인덱스 + Not Null 속성을 띄고 있다.<br>
    -유니크 인덱스도 한꺼번에 비클러스터 인덱스로 보기도 한다. (어쨌든 기본 키는 아니므로)
    </details>
    
- **왜 보편적으로 해시 테이블 대신 B-Tree 자료 구조를 DB 인덱스로 사용하는가?**
    
    <details>
        해시 테이블 내의 데이터는 정렬이 되어 있지 않으므로 부등호 연산이 불가능하다. <br>
    인덱스의 특성상 기준 값보다 크거나 작은 요소를 탐색하는 경우가 많은데, 이러한 이유로 B-Tree를 인덱스의 자료 구조로 사용한다.
    </details>
    
- **오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.**
    
    <details>
    내림차순으로 탐색을 하기 위해서는 오름차순으로 정렬된 인덱스에서 맨 끝부터 탐색을 시작해야 합니다. <br>
    하지만 B-Tree나 B+Tree는 노드를 왼쪽에서 오른쪽으로 저장하므로, 인덱스를 끝에서부터 탐색하는 것은 구조적으로 비효율적입니다. 이로 인해 성능이 저하됩니다. <br>
    <br>
    내림차순으로 정렬된 인덱스를 사용해야 하는 경우, 인덱스를 생성할 때 내림차순으로 정렬된 인덱스를 생성하거나, 
    오름차순으로 정렬된 인덱스를 사용하되, 역순으로 탐색하는 방법을 사용할 수 있습니다. <br>
    후자의 경우, 오름차순으로 정렬된 인덱스를 사용하여 탐색한 후, 결과를 역순으로 반환하는 방법을 사용합니다. <br>
    이 방법은 내림차순으로 정렬된 인덱스를 사용하는 것보다는 성능이 좋지만, 오름차순으로 정렬된 인덱스를 사용하는 것보다는 성능이 떨어집니다.
    </details>
    
- **인덱스를 사용하는 칼럼을 검색하게 되면 어떤 파일의 내용을 활용하나요?**
    
    <details>
    MYI(index 정보 파일) <br>
    </details>
    
    
    참고 : https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/%5BDB%5D%20Index.md
    
- **covering index란?**
    
    <details>
    조회하는 특성들의 index가 모두 cover될 때<br>
    실무에서 조회 성능을 높이기 위해 종종 사용한다.<br>
    인덱스 크기가 증가하고 추가 디스크 공간이 필요하다는 단점이 있다.<br>
    </details>
    
- **Index 데이터 구조 중에서 B-tree구조 이외의 다른 구조에 대해 아는가?**
    
    <details>
    Hash Index, Bitmap Index, R-tree Index, Gist Index
    </details>
 
- **Index를 사용하여 탐색하는 것보다 Full Scan탐색이 더 좋은 상황이 있는가?**
    
    <details>
    table에 데이터가 조금 있을 때, 조회하려는 데이터가 테이블의 상당 부분을 차지할 때<br>
    index 사용할 지 Full Scan할 지는 optimizer가 판단
    </details>

### 트랜잭션

- **트랜잭션이란? **

  <details>
  데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위
  </details>

- **트랜잭션의 특징은?**

  <details>
  Atomicity(원자성) : 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 한다.<br>
  Consistency(일관성) : 트랜잭션의 작업처리 결과는 항상 일관성 있어야 한다.<br>
  Isolation(독립성) : 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.<br>
  Durability(지속성) : 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.
  </details>

- **트랜잭션의 상태는? **

  <details>
  활동(Active)- 트랜잭션이 실행 중인 상태<br>
  장애(Fail)-트랜잭션이 실행에 오류가 발생하여 중단한 상태<br>
  철회(Aborted)-트랜잭션이 비정상적으로 종료되어 Rollback 수행하는 상태<br>
  부분 완료(Partially Commit)-트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전 상태<br>
  완료(Commmitted)-트랜잭션이 성공적으로 종료되어 commit 연산을 실행한 후의 상태
  </details>

- **커밋이란? **

  <details>
  하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 알려주기 위해 사용하는 연산
  </details>

- **롤백이란?**

  <details>
  롤백은 특정 트랜잭션 또는 트랜잭션 세트를 취소하여 데이터베이스를 이전 상태로 복원하는 작업입니다. <br>
      트랜잭션이 정상적으로 종료되지 않았을 때, Last Consitent state로 RollBack 할 수 있음.
  </details>

  

### 정리 링크

* 수민 : https://sustco.tistory.com/44 (비밀번호 : 1234)
