## 스터디 주제

* 페이지 & 세그먼테이션
* 페이지 교체 알고리즘
* 대칭키 & 공개키

## 페이지 & 세그먼테이션

- 페이지와 세그먼테이션을 각각 설명하세요.
  <details>
   
  페이지는 고정 사이즈의 작은 프로세스 조각이고, 세그먼테이션은 가변적인 영역인 세그먼트로 분할하는 것을 말한다.
    
  페이지 크기가 작으면 내부 단편화가 줄어들고, 페이지 사상 테이블은 늘어나며, 페이지 부재가 늘어난다.   
    
  페이지 부재 현상이 많이 일어나면 성능이 떨어진다.
  
  이러한 기법들은 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요하기 때문이다.
  </details>
- 내부 단편화와 외부 단편화에 대해 설명하세요.
  <details>
  단편화란 기억 장치의 빈 공간 또는 자료가 여러 조각으로 나뉘는 현상이다. 프로세스들이 메모리에 적재되고 제거되는 일이 반복되면 프로세스들이 차지하는
  메모리 틈 사이에 사용하지 못할 만큼의 자유 공간이 늘어나게 된다.
  
  내부단편화: 주기억장치 내 사용자 영역이 실행 프로그램보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남게 되는 현상을 말한다.
  
  외부단편화: 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적이지 않아 발생하는 현상
  
  
  </details>
  
- 내부 단편화와 외부 단편화 해결 방법에 대해 설명하세요.

  <details>
  내부 단편화는 통합과 압축, slab allocator 방식으로 해결한다. slab allocator은 페이지 프레임을 할당받아 공간을 작은 크기로 분할하고 메모리 요청시 작은 크기로 메모리를 할당/해제하는 동적 메모리 기법이다.
  
  외부 단편화는 통합과 압축, 버디 메모리 할당 방식으로 해결한다. 버디 메모리 할당 방식은 요청한 프로세스 크기에 가장 알맞은 크기를 할당하기 위해 메모리를 2의 지수승 크기로 분할하여 메모리를 할당하는 기법이다.
  </details>

- 스레싱이란?
  <details>
    어떤 프로세스가 계속적으로 페이지 부재가 발생하여 프로세스의 실제 처리 시간보다 페이지 교체 시간이 더 많아지는 현상이다.
  
    오류율이 클수록 스레싱이 많이 많이 발생한 것이고, 스레싱으로 인해 전체 시스템의 성능 및 처리율은 저하된다.
    페이지 부재가 계속 증가하여 기억장치 접근 시간이 증가한다.
  </details>
  
 - 페이징 기법의 해결방안 중에 하나인 '워킹 세트'라는 것이 있는데 설명하세요.
    <details>
      각 프로세스가 많이 참조하는 페이지들의 집합을 주기억장치 공간에 계속 상주하게 하여 빈번한 페이지 교체 현상을 줄이고자 하는 기법이다. 이 기법은 워킹 세트
      추적관리가 복잡하고, 워킹 세트 크기 설정의 모호함이 발생한다.
    </details>
    
 - 페이지, 프레임을 설명하세요.
    <details>
      페이지는 고정 사이즈의 가상 메모리 내 프로세스 조각이고, 프레임은 페이지 크기와 같은 주기억장치의 메모리 조각이다.
    </details>
## Semaphore & Mutex

- Semaphore 방식에 대해 설명해주세요.
    <details>
    `**세마포어** : 멀티 프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법`
    </details>

- Semaphore의 동작 과정에 대해 설명해주세요.
    <details>
    1. 먼저 도착한 A가 P(S)를 실행하여, S를 0으로 만들고 임계구역에 들어감
    2. 그 뒤에 도착한 B가 P(S)를 실행하지만 S가 0이므로 대기상태
    3. A가 임계 구역 수행을 마치고 V(S)를 실행하면 S는 다시 1이 됨
    4. B는 이제 P(S)에서 while 문을 빠져나올 수 있고, 임계 구역으로 들어가 수행함
    </details>

- Semaphore가 제대로 동작하지 않는 경우 설명해주세요.
    <details>
    - 프로세스가 세마포어를 사용하지 않고 바로 임계구역에 들어간 경우 → 임계구역을 보호할 수 없다.
    - `P()`를 두번 사용하여, wake_up 신호가 발생하지 않은 경우
    - 프로세스 간의 동기화가 이루어지지 않아, 세마포어 큐에서 대기하고 있는 프로세스들이 무한 대기에 빠진다.  
    - `P()` 와 `V()`를 반대로 사용하여, 상호 배제가 보장되지 않은 경우, 임계구역을 보호할 수 없다.
    </details>


- Mutex 방식에 대해 설명해주세요.
    <details>
    **`Mut`**ual **`Ex`**clusion 의 약자로서 임계 구역(Critical Section)을 가진 스레드들의 실행시간이 서로 겹치지 않고 단독으로 실행되게 하는 기술
    </details>
- Mutex lock 이란?
    <details>
    하나의 프로세스가 key를 가지고 임계 영역에 들어가서 lock을 걸면, 그 키를 가지고 있지 않은 다른 프로세스들은 임계 영역에 들어가지 못하고 기다리게 됩니다.
    
    실행 중인 프로세스가 모두 처리 후 키를 반환하면, 그 때 대기하던 프로세스 중 하나가 들어갈 수 있습니다.
    </details>
- Semaphore 방식과 Mutex방식의 차이점을 설명해주세요.
    <details>
    세마포어는 자원 풀에 대한 접근을 규제하는 데 사용되는 반면 뮤텍스는 단일 공유 자원에 대한 접근을 규제하는 데 사용된다.

    - 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없음
    - **세마포어는 소유 불가능하지만, 뮤택스는 소유가 가능함**
        - 뮤텍스 - 접근 불가능
        - 이진 세마포어 - 접근 가능
    - 동기화의 개수가 다름

    </details>
- 동시 프로그래밍에서 뮤텍스의 목적과 이진 세마포어와의 차이점은 무엇인가요?
    <details>
    뮤텍스의 목적은 상호 배제를 보장하는 것이며, 뮤텍스는 공유 리소스에 대한 접근을 사전에 방지하는 잠금기능을 제공하며, 이진 세마포어와는 다르게 뮤텍스는 공유자원을 점유했을 때 소      유한 스레드만이 잠금을 해제할 수 있는 유일한 스레드라는 소유개념을 가지고 있다.
    </details>
- 뮤텍스 대신 세마포어 방식을 사용하는 경우는 어떤 경우인가요? 그 예시를 들어주세요.
    <details>
    뮤텍스 대신 세마포어를 사용하는 시나리오는 하나의 공유 리소스가 아닌 리소스 풀에 대한 액세스를 규제해야 하는 경우입니다.
    
    세마포어는 네트워크 연결이나, DB Connection 의 접근을 제어하지만, 뮤텍스는 단일 공유 데이터에 대한 접근을 제어한다.
    
    node js & mysql <<
    </details>
- 세마포어와 뮤텍스방식을 이용할 때 데드락이 발생할 수 있나요? 발생한다면 해결방법은?
    <details>
    교착 상태를 피하려면 모든 스레드가 동일한 순서로 잠금을 획득하는지 확인하고, 가능한 한 빨리 잠금을 해제하고, 순환 대기 조건을 피하는 것과 같은 몇 가지 일반적인 지침을 따르는 것이 중요하다.
    </details>

- 스핀락이란 Lock을 가질 수 있을 때까지 반복해서 시도하는 작업을 말한다. 이로 인해 Busy Waiting이 발생할 위험이 있다. 그렇다면 뮤텍스가 스핀락 보다 항상 좋은 것일까?
    <details>
    스핀락이 더 좋은 경우

    - 멀티 코어 환경
    - 임계 구역에서 작업이 컨텍스트 스위칭보다 빨리 끝나면
    참고자료 : [스핀락과 뮤텍스](https://www.youtube.com/watch?v=gTkvX2Awj6g)
    </details>

## UDP

- TCP 와 UDP의 차이점은 무엇인가요?
    <details>
    **TCP**는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정하기 때문에 높은 신뢰성을 보장하지만, 속도가 비교적 느리다는 단점이 있습니다.
    
    **UDP**는 비연결형 서비스로 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있지만, 데이터 수신 여부를 확인하지 않기 때문에 속도가 빠르다는 장점이 있습니다.
    </details>
- UDP를 사용하는 경우
    <details>
    RTP, 멀티캐스트, DNS, 멀티미디어
    </details>
- UDP의 장단점?
    <details>
    장점
    
    - 낮은 오버헤드
    - 빠른 통신
    - 비교적 간단한 구현
    
    단점
    
    - 신뢰성의 부족
    - 흐름제어 어려움
    - 데이터의 손실, 손상위험이 증가
  </details>
- UDP에서 흐름제어와 신뢰성을 어떻게 보장하나요?
    <details>
    보장 못한다. UDP는 신뢰성과 흐름제어를 보장하는 별도의 메커니즘을 가지고 있지 않기 때문에. 이를 처리하기 위한 일들을 애플리케이션 계층에 의존한다.
    </details>
- DNS에서 UDP를 사용하는 이유?
    <details>
    Request의 양이 작다 → UDP Request에 담길 수 있다.
    1. 3 way handshake로 연결을 유지할 필요가 없다.
    2. Request에 대한 손실은 Application Layer에서 제어가 가능하다.
    3. DNS : port 53번
        - 그렇지만 크기가 512(UDP 제한)을 넘기면, TCP를 사용해야 한다.
    </details>
- UDP를 사용하기 적합한 상황과 TCP를 사용하기 적합한 상황을 이야기 해주실수 있나요?
    <details>
    UDP
    
    - 실시간 게임이나 스트리밍 환경같은 낮은 지연시간과 빠른 통신이 중요한 경우
    
    TCP
    
    - 파일 전송이나 이메일과 같은 신뢰성과 데이터 무결성이 중요한 경우
    </details>
- UDP의 CheckSum에 대해 설명해주실 수 있나요?
    <details>
    이렇게 계산한 checksum 값을 송신측에서 checksum 영역에 넣어서 송신측에 보내면 송신측도 마찬가지로 sum값을 구하고, checksum 값을 구해서 송신측에서 보낸 checksum 과 동일한지 확인한다. 만약 동일하다면 에러가 없는 것이고 동일하지 않다면 에러가 있다는 것을 확인 할 수 있다.
    
    ⇒ 에러 검출
    </details>
- UDP 와 WebSocket의 차이점?

- 최근 발표한 HTTP 3.0 버전에서는 TCP 기반의 프로토콜이 아닌 UDP 기반의 QUIC 프로토콜을 채택하였다. 왜 그런 지 알고 있는가?
    <details>

    1. TCP 구조 상 한계로 개선해도 여전히 느리다
        - 와이파이를 바꾸면, 다시 새로운 커넥션을 맺어야 하기 때문에 끊김 현상
        - 중간에 패킷이 유실되거나, 수신 측의 패킷 파싱 속도가 느리면 통신에 병목 발생 (HOLB)
    2. UDP는 신뢰성이 없는 게 아니라, 탑재를 안했을 뿐
        - 커스터마이징이 가능
    </details>

## 정리 링크
