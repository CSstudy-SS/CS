## 스터디 주제

* Blocking, Non-Blocking & Synchronous, Asynchronous
* Blocking & Non-Blocking I/O
* SQL - JOIN

## 질문목록

### Blocking, Non-Blocking & Synchronous, Asynchronous

- blocking과 non-blocking의 차이점은 무엇인가요?

  <details>
    blocking은 작업이 끝날 때까지 다른 작업을 수행하지 않고 기다리는 것이고, non-blocking은 작업이 진행되는 동안 다른 작업을 수행할 수 있는 것
  </details>
- 동기, 비동기 방식의 차이점은?
  <details>
    동기는 요청과 응답이 한 번에 처리되는 방식이다. 요청한 작업이 완료될 때까지 다음 작업을 처리하지 않는다.<br>
    반면에 비동기는 요청한 작업의 완료 여부와는 관계없이 다음 작업을 처리하고, 요청한 작업이 완료되면, 이벤트나 콜백을 통해 결과값을 받아온다.
  </details>
- 비동기와 non-block의 차이는?

  <details>
    - 비동기식 처리는 요청을 처리하는 동안 다른 작업을 수행할 수 있고, 작업이 완료될 때 결과를 수신합니다. 
    - 반면, non-blocking은 요청을 처리하는 동안 다른 작업을 수행할 수는 있지만, 작업이 완료되지 않으면 결과를 받을 수 없다.
  </details>

- blocking 방식의 단점은

  <details>
      - 작업이 완료될 때까지 다른작업을 수행하지 못하므로, 대기시간이 증가하여 성능 저하가 일어날 수 있다.<br>
      - 특히 I/O작업의 경우에는 더 느려질 수가 있다.
  </details>

- 동기와 비동기 방식의 장단점은?
  <details>
    - 동기 방식의 장점은 간단하고 직관적인 코드를 작성할 수 있으며, 결과를 즉시 얻을 수 있다는 것입니다. 그러나 작업이 완료될 때까지 다른 작업을 수행하지 못하므로, 전체적인 처리 속       도가 저하될 수 있습니다.<br>
    - 비동기 방식의 장점은 작업을 동시에 처리할 수 있으므로, 전체적인 처리 속도가 빠르며, 대용량 처리가 가능하다는 것입니다. 하지만 구현이 복잡하고, 코드가 더 복잡해질 수 있다는 단       점이 있습니다.
  </details>


- 그렇다면 동기이면서 논블로킹이고 비동기이면서 블로킹인 경우는 의미가 있다고 할 수 있나요?

  <details>
  많이 사용되지는 않지만, 동기면서 논블로킹인 경우는 예를들어, Future.isDone()이 있습니다. isDone()은 작업이 완료되지 않았다면 Fasle를 바로 리턴해줍니다.
  isDone()을 호출하는 쪽에서 계속 isDone()을 호출하면서 작업완료를 신경쓰고, while(!future.isDone())에 있는 코드들은 작업이 완료되지 않아도 별개로 작업이 가능하다. 
  <br> + 게임에서 로딩률을 표시할 때가 해당
  <br>
  비동기이면서 블로킹인 경우는 Node.js와 Mysql의 조합이 대표적이다. Node.js쪽에서 Async로 해도, MySQL에서 제공하는 드라이버를 호출하게 되는데, 이것은 블로킹방식이라고 한다.
  결국 논블로킹-비동기 방식을 쓰는데, 그 과정에서 하나라도 블로킹으로 동작하는 게 있다면 의도치 않게 블로킹-비동기로 동작할 수 있다.
  <br>
      따라서, 이러한 조합은 특정 상황에서 유용할 수 있지만, 일반적으로는 사용되지 않는 조합이기 때문에 주의해서 사용해야 합니다.</details>

### Blocking & Non-Blocking I/O

- 블로킹 I/O 와 논블로킹 I/O이란?

  <details>
    <블로킹>
    <br>
    - B가 끝날 때까지 A에게 제어권(주도권)을 바로 돌려주지 않는 경우(주도권이 B에게 있음)<br>
    - B가 끝날 때 까지 A는 아무 일도 할 수 없음<br>

    <논블로킹>
    <br>
    - B가 끝나지 않더라도 A에게 제어권(주도권)을 바로 돌려주는 경우(주도권이 A에게 있음)<br>
    - B가 끝나지 않더라도 A는 다른 일을 할 수 있음<br>
  </details>

- Asynchronous blocking I/O 를 사용할 때의 예시와 문제점은?

  <details>
    비동기적으로 코드가 실행되지만, blocking IO작업을 위해 주기적으로 polling작업을 수행하는 오버헤드가 발생한다.
  </details>


- blocking i/o 의 과정에 대해 설명하시오.

  <details>
  1. 프로세스가 커널에게 i/o를 요청하는 함수를 호출<br>
  2. 프로세스는 작업결과를 반환 받을 때까지 대기<br>
  3. 커널이 작업을 완료하면 작업 결과를 반환 받음<br>
  (이 경우 말 그대로 block이 되고, 어플리케이션에서 다른 작업을 수행하지 못하고 대기하게 되므로 Resource 낭비가 심하다.)<br>
      또한, 여러 클라이언트가 접속하는 서버를 blocking으로 구현할 경우 많아진 쓰레드로 인해 context switching 횟수가 증가한다.</details>

- non blocking i/o의 과정에 대해 설명하시오

  <details>I/O 작업이 진행되는 동안 User Process의 작업을 중단하지 않음.<br>
  <br>
  1. read I/O를 하기 위해 system call <br>
  2. 커널의 I/O 작업 완료 여부와 관계없이 즉시 응답(이는 커널이 system call을 받자마자 CPU 제어권을 다시 어플리케이션에 넘겨주는 작업)<br>
  3. 어플리케이션은 I/O 작업이 완료되기 전에 다른 작업을 수행 가능<br>
  4. 어플리케이션은 다른 작업 수행 중간중간에 system call을 보내 I/O가 완료되었는지 커널에 요청하고, 완료되면 I/O 작업을 완료<br>
  <br>
  이러한 과정을 통해 모든 작업 수행이 I/O의 진행시간과는 관계없이 빠르게 동작하기 때문에, User Process는 자신의 작업을 오랜시간 중지하지 않고도 I/O 처리를 수행할 수 있다.
  그러나 반복적으로 system call이 발생하기 때문에 이것 또한 Resource 낭비가 된다.
  <br>
  ------
  <br> 조금 더 구체적으로 <br>
  1. User Process가 recvfrom 함수 호출 (커널에게 해당 Socket으로부터 data를 받고 싶다고 요청함)<br>
  2. Kernel은 이 요청에 대해서, 곧바로 recvBuffer를 채워서 보내지 못하므로, "EWOULDBLOCK"을 return함.<br>
  3. Blocking 방식과 달리, User Process는 다른 작업을 진행할 수 있음.<br>
  4. recvBuffer에 user가 받을 수 있는 데이터가 있는 경우, Buffer로부터 데이터를 복사하여 받아옴. <br>
  (이때, recvBuffer는 Kernel이 가지고 있는 메모리에 적재되어 있으므로, Memory간 복사로 인해, I/O보다 훨씬 빠른 속도로 data를 받아올 수 있음.)<br>
  5. recvfrom 함수는 빠른 속도로 data를 복사한 후, 복사한 data의 길이와 함께 반환함.
  </details>

- I/O 멀티플렉싱이란? (feat. chatGPT)

  <details>I/O 멀티플렉싱(I/O Multiplexing)은 하나의 프로세스나 스레드가 여러 개의 I/O 작업을 동시에 처리할 수 있도록 하는 기술입니다.
  I/O 멀티플렉싱은 운영체제의 시스템 콜인 select()나 poll()을 사용하여 여러 개의 파일 디스크립터(File Descriptor)를 모니터링합니다. 
  이 때 파일 디스크립터는 일반적으로 소켓(Socket)이나 파일(File)을 가리킵니다.
  I/O 멀티플렉싱은 select()나 poll() 함수가 호출되면서 모니터링 대상으로 등록된 파일 디스크립터 중에서 
  어떤 파일 디스크립터에 대해 입출력 작업이 가능해졌는지를 확인합니다. 
  입출력 작업이 가능해진 파일 디스크립터에 대해서만 read()나 write() 함수를 호출하여 입출력 작업을 수행합니다. 
  이렇게 함으로써, 하나의 프로세스나 스레드가 여러 개의 I/O 작업을 동시에 처리할 수 있게 됩니다.

### Key 정리

- db에서 JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.

  <details>
  Nested Loop Join<br>
  Nested Loop Join은 가장 간단한 JOIN 알고리즘 중 하나입니다.<br>
  두 개의 테이블을 중첩 반복문으로 순회하면서 매칭되는 레코드를 찾습니다. 
  이 알고리즘은 간단하지만, 큰 테이블을 가지고 JOIN을 수행할 경우 성능 문제가 발생할 수 있습니다.
  <br>
  Sort Merge Join <br>
  Sort Merge Join은 두 개의 테이블을 각각 정렬한 후에 병합하는 방식으로 JOIN을 수행합니다. <br>
  이 알고리즘은 정렬이 필요하므로 많은 자원과 시간이 소요될 수 있습니다. 
  그러나 정렬된 데이터를 병합하는 방식이므로, 메모리가 제한적인 경우에도 사용할 수 있습니다.
  <br>
  Hash Join<br>
  Hash Join은 두 개의 테이블에서 해시 함수를 사용하여 매칭되는 레코드를 찾는 방식으로 JOIN을 수행합니다. <br>
  이 알고리즘은 많은 자원을 요구하지만, 빠른 성능을 보장합니다. 
  해시 함수를 사용하기 때문에 레코드의 키 값을 해싱하여 메모리에 저장해야 하므로, 메모리가 부족한 경우에는 문제가 될 수 있습니다.
  <br>
  Merge Join with Indexes<br>
  Merge Join with Indexes는 두 개의 테이블에서 인덱스를 사용하여 JOIN을 수행하는 방식입니다. <br>
  인덱스를 사용하기 때문에 테이블을 스캔하지 않아도 되므로, Nested Loop Join 보다 빠른 성능을 보장할 수 있습니다. 
  그러나 인덱스를 만드는데 시간과 자원이 많이 필요하므로, 인덱스를 미리 만들어 놓는 것이 좋습니다.
  <br> 참고 <br>
  https://velog.io/@jduck1024/%EC%A1%B0%EC%9D%B8-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EB%A6%AC
  </details>

- 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?

  <details>
  입력한 쿼리에서 사용되는 JOIN 알고리즘은 DBMS에 따라 다릅니다. 일반적으로 DBMS는 입력받은 쿼리를 최적화하고 실행 계획을 결정하기 위해 쿼리 옵티마이저(Query Optimizer)를 사용합니다.
  쿼리 옵티마이저는 입력받은 쿼리를 분석하여 어떤 JOIN 알고리즘을 사용할지 결정합니다. 이때, 사용되는 JOIN 알고리즘은 입력받은 쿼리의 조건절, 테이블의 크기, 인덱스의 존재 여부 등 다양한 요인에 따라 결정됩니다.
  일부 DBMS에서는 쿼리 실행 계획을 확인할 수 있는 EXPLAIN 문을 지원합니다. <br>
  EXPLAIN 문을 실행하면 DBMS는 쿼리 실행 계획을 출력하여 어떤 JOIN 알고리즘이 사용되는지 확인할 수 있습니다.
  그러나 EXPLAIN 문을 사용하지 않더라도, DBMS가 최적의 실행 계획을 결정하기 위해 쿼리 옵티마이저를 사용한다는 점은 알고 있어야 합니다. 
  따라서, 쿼리를 작성할 때는 최적화 가능한 쿼리를 작성하여 쿼리 옵티마이저가 최적의 실행 계획을 결정할 수 있도록 해야 합니다.
  </details>

- 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?

  <details>
    네, JOIN 성능도 인덱스의 유무와 종류에 따라 영향을 받습니다.
  JOIN은 테이블 간의 관계를 연결하여 결과를 출력하는 작업입니다. 이때, JOIN을 수행하는 컬럼에 인덱스가 존재하면 인덱스를 이용하여 빠른 검색이 가능합니다. 즉, JOIN 조건에 사용되는 컬럼에 인덱스가 있다면 JOIN을 수행할 때 더 빠르게 처리될 수 있습니다.
  예를 들어, 테이블 A와 B를 JOIN 할 때, A 테이블의 컬럼 x와 B 테이블의 컬럼 y를 JOIN 조건으로 사용한다면, A 테이블의 x 컬럼과 B 테이블의 y 컬럼에 인덱스가 있다면 JOIN 성능이 향상될 수 있습니다.<br>
  하지만, JOIN 조건에 사용되는 컬럼에 인덱스가 존재하지 않는다면, DBMS는 전체 테이블 스캔을 수행하여 JOIN을 수행하게 됩니다. 
  이 경우, 대용량 데이터에서는 처리 시간이 많이 소요될 수 있습니다.
  따라서, JOIN을 수행할 때는 JOIN 조건에 사용되는 컬럼에 적절한 인덱스를 생성하여 JOIN 성능을 최적화하는 것이 중요합니다.
  </details>
- SQL JOIN이란?
    <details>
      SQL 조인은 두 개 이상의 테이블 사이의 관련 열을 기준으로 데이터를 결합하는 방식입니다.<br>
      단일 쿼리에서 여러 테이블의 데이터를 검색할 수 있습니다.
    </details>
    
- JOIN의 종류는?
    <details>
      - inner join<br>
      - left join<br>
      - right join<br>
      - full outer join<br>
    </details>
- inner join 과 left join의 차이점?
    <details>
      inner join은 두 테이블 사이의 일치하는 행만을 반환하고, left join은 왼쪽 테이블의 모든 행과 오른쪽 테이블에 일치하는 행을 반환한다.
    </details>
    
## 정리 링크

수민 : https://sustco.tistory.com/42 비밀번호:1234<br>
준엽 : https://www.notion.so/Week10-Network-DataBase-44daeaae93694643aa7e00a27f4debae
세정 : [10주차 공부 정리](https://evening-november-9ec.notion.site/10-465845b77e2946009865c0632c6b2368)