## 스터디 주제

* Blocking, Non-Blocking & Synchronous, Asynchronous
* Blocking & Non-Blocking I/O
* SQL - JOIN

## 질문목록

### Blocking, Non-Blocking & Synchronous, Asynchronous

- TLS handshake 과정을 설명해주세요

  <details>


      1. 클라이언트는 서버에게 `client hello` 메시지를 담아 서버로 보낸다. 이때 암호화된 정보를 함께 담는데, `버전`, `암호 알고리즘`, `압축 방식` 등을 담는다.

      2. 서버는 클라이언트가 보낸 암호 알고리즘과 압축 방식을 받고, `세션 ID`와 `CA 공개 인증서`를 `server hello` 메시지와 함께 담아 응답한다. 이 CA 인증서에는 앞으로 통신 이후 사용할 대칭키가 생성되기 전, 클라이언트에서 handshake 과정 속 암호화에 사용할 공개키를 담고 있다.

      3. 클라이언트 측은 서버에서 보낸 CA 인증서에 대해 유효한 지 CA 목록에서 확인하는 과정을 진행한다.

      4. CA 인증서에 대한 신뢰성이 확보되었다면, 클라이언트는 난수 바이트를 생성하여 서버의 공개키로 암호화한다. 이 난수 바이트는 대칭키를 정하는데 사용이 되고, 앞으로 서로 메시지를 통신할 때 암호화하는데 사용된다.

      5. 만약 2번 단계에서 서버가 클라이언트 인증서를 함께 요구했다면, 클라이언트의 인증서와 클라이언트의 개인키로 암호화된 임의의 바이트 문자열을 함께 보내준다.

      6. 서버는 클라이언트의 인증서를 확인 후, 난수 바이트를 자신의 개인키로 복호화 후 대칭 마스터 키 생성에 활용한다.

      7. 클라이언트는 handshake 과정이 완료되었다는 `finished` 메시지를 서버에 보내면서, 지금까지 보낸 교환 내역들을 해싱 후 그 값을 대칭키로 암호화하여 같이 담아 보내준다.

      8. 서버도 동일하게 교환 내용들을 해싱한 뒤 클라이언트에서 보내준 값과 일치하는 지 확인한다. 일치하면 서버도 마찬가지로 `finished` 메시지를 이번에 만든 대칭키로 암호화하여 보낸다.

      9. 클라이언트는 해당 메시지를 대칭키로 복호화하여 서로 통신이 가능한 신뢰받은 사용자란 걸 인지하고, 앞으로 클라이언트와 서버는 해당 대칭키로 데이터를 주고받을 수 있게 된다.

  </details>

- TLS란?

  <details>
    Transport Layer Security의 약자로서

  인터넷에서의 정보를 암호화해서 송수신하는 프로토콜, 넷스케이프 커뮤니케이션스사가 개발한 국제 인터넷 표준화 기구에서 표준으로 인정받은 프로토콜이다. TCP443 포트를 사용한다.
  </details>

- TLS 와 SSL의 차이점은?

  <details>
  보안: TLS는 더 강력한 암호화 알고리즘, 더 나은 인증 메커니즘 및 향상된 키 교환 프로토콜을 가지고 있습니다.


  프로토콜 버전: SSL은 2015년 이후 더 이상 안전하지 않으며 TLS는 계속 개발 및 개선되고 있습니다. TLS는 TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3을 포함한 여러 버전이 있으며, 각 버전은 이전 버전보다 더 나은 보안을 제공한다.

  등 성능, 호환성 모든 부분에서 ssl보다 좋다.
  </details>

- 그렇다면 동기이면서 논블로킹이고 비동기이면서 블로킹인 경우는 의미가 있다고 할 수 있나요?

  <details>
  많이 사용되지는 않지만, 동기면서 논블로킹인 경우는 예를들어, Future.isDone()이 있습니다. isDone()은 작업이 완료되지 않았다면 Fasle를 바로 리턴해줍니다.
  isDone()을 호출하는 쪽에서 계속 isDone()을 호출하면서 작업완료를 신경쓰고, while(!future.isDone())에 있는 코드들은 작업이 완료되지 않아도 별개로 작업이 가능하다. 
  <br> + 게임에서 로딩률을 표시할 때가 해당
  <br>
  비동기이면서 블로킹인 경우는 Node.js와 Mysql의 조합이 대표적이다. Node.js쪽에서 Async로 해도, MySQL에서 제공하는 드라이버를 호출하게 되는데, 이것은 블로킹방식이라고 한다.
  결국 논블로킹-비동기 방식을 쓰는데, 그 과정에서 하나라도 블로킹으로 동작하는 게 있다면 의도치 않게 블로킹-비동기로 동작할 수 있다.
  <br>
      따라서, 이러한 조합은 특정 상황에서 유용할 수 있지만, 일반적으로는 사용되지 않는 조합이기 때문에 주의해서 사용해야 합니다.</details>

### Blocking & Non-Blocking I/O

- 대규모 트래픽에 대처할 수 있는 방법

  <details>


    서버의 성능을 높이는 Scale-up과 분산 처리를 위해 여러 대의 서버를 두는 Scale-out이 있다. Scale-up 방식의 경우 한계가 있으므로 주로 Scale-out 방식을 사용한다. Scale-out 방식에서 분산 처리를 하기 위해 로드 밸런싱 기술을 사용한다.

  </details>

- Scale out 의 장점이 무엇인지 설명해주세요

  <details>


    - 하드웨어 향상하는 비용보다 서버 한대 추가 비용이 더 적습니다.

    - 여러 대의 Server 덕분에 무중단 서비스를 제공할 수 있습니다.

  </details>


- 로드 밸런서의 기본 기능은?

  <details>


    - 서버의 이상 유무를 파악하는 상태 확인(Health Check)

    - 패킷을 캡슐화해서 연결된 상호 간에만 패킷을 구별할 수 있게 해주는 터널링(Tunneling)

    - IP 주소를 변환해주는 NAT 기능이 있다.

  </details>


- 로드 밸런서의 종류?

  <details>


    로드 밸런서는 OSI 7계층을 기준으로 어떻게 부하를 분산하는 지에 따라 종류가 나뉜다. 그 중 L4 로드 밸런서와 L7 로드 밸런서가 가장 많이 활용된다.

  </details>




- blocking i/o 의 과정에 대해 설명하시오.

  <details>
  1. 프로세스가 커널에게 i/o를 요청하는 함수를 호출<br>
  2. 프로세스는 작업결과를 반환 받을 때까지 대기<br>
  3. 커널이 작업을 완료하면 작업 결과를 반환 받음<br>
  (이 경우 말 그대로 block이 되고, 어플리케이션에서 다른 작업을 수행하지 못하고 대기하게 되므로 Resource 낭비가 심하다.)<br>
      또한, 여러 클라이언트가 접속하는 서버를 blocking으로 구현할 경우 많아진 쓰레드로 인해 context switching 횟수가 증가한다.</details>

- non blocking i/o의 과정에 대해 설명하시오

  <details>I/O 작업이 진행되는 동안 User Process의 작업을 중단하지 않음.<br>
  <br>
  1. read I/O를 하기 위해 system call <br>
  2. 커널의 I/O 작업 완료 여부와 관계없이 즉시 응답(이는 커널이 system call을 받자마자 CPU 제어권을 다시 어플리케이션에 넘겨주는 작업)<br>
  3. 어플리케이션은 I/O 작업이 완료되기 전에 다른 작업을 수행 가능<br>
  4. 어플리케이션은 다른 작업 수행 중간중간에 system call을 보내 I/O가 완료되었는지 커널에 요청하고, 완료되면 I/O 작업을 완료<br>
  <br>
  이러한 과정을 통해 모든 작업 수행이 I/O의 진행시간과는 관계없이 빠르게 동작하기 때문에, User Process는 자신의 작업을 오랜시간 중지하지 않고도 I/O 처리를 수행할 수 있다.
  그러나 반복적으로 system call이 발생하기 때문에 이것 또한 Resource 낭비가 된다.
  <br>
  ------
  <br> 조금 더 구체적으로 <br>
  1. User Process가 recvfrom 함수 호출 (커널에게 해당 Socket으로부터 data를 받고 싶다고 요청함)<br>
  2. Kernel은 이 요청에 대해서, 곧바로 recvBuffer를 채워서 보내지 못하므로, "EWOULDBLOCK"을 return함.<br>
  3. Blocking 방식과 달리, User Process는 다른 작업을 진행할 수 있음.<br>
  4. recvBuffer에 user가 받을 수 있는 데이터가 있는 경우, Buffer로부터 데이터를 복사하여 받아옴. <br>
  (이때, recvBuffer는 Kernel이 가지고 있는 메모리에 적재되어 있으므로, Memory간 복사로 인해, I/O보다 훨씬 빠른 속도로 data를 받아올 수 있음.)<br>
  5. recvfrom 함수는 빠른 속도로 data를 복사한 후, 복사한 data의 길이와 함께 반환함.
  </details>

- I/O 멀티플렉싱이란? (feat. chatGPT)

  <details>I/O 멀티플렉싱(I/O Multiplexing)은 하나의 프로세스나 스레드가 여러 개의 I/O 작업을 동시에 처리할 수 있도록 하는 기술입니다.
  I/O 멀티플렉싱은 운영체제의 시스템 콜인 select()나 poll()을 사용하여 여러 개의 파일 디스크립터(File Descriptor)를 모니터링합니다. 
  이 때 파일 디스크립터는 일반적으로 소켓(Socket)이나 파일(File)을 가리킵니다.
  I/O 멀티플렉싱은 select()나 poll() 함수가 호출되면서 모니터링 대상으로 등록된 파일 디스크립터 중에서 
  어떤 파일 디스크립터에 대해 입출력 작업이 가능해졌는지를 확인합니다. 
  입출력 작업이 가능해진 파일 디스크립터에 대해서만 read()나 write() 함수를 호출하여 입출력 작업을 수행합니다. 
  이렇게 함으로써, 하나의 프로세스나 스레드가 여러 개의 I/O 작업을 동시에 처리할 수 있게 됩니다.

### Key 정리

- db에서 JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.

  <details>
  Nested Loop Join<br>
  Nested Loop Join은 가장 간단한 JOIN 알고리즘 중 하나입니다.<br>
  두 개의 테이블을 중첩 반복문으로 순회하면서 매칭되는 레코드를 찾습니다. 
  이 알고리즘은 간단하지만, 큰 테이블을 가지고 JOIN을 수행할 경우 성능 문제가 발생할 수 있습니다.
  <br>
  Sort Merge Join <br>
  Sort Merge Join은 두 개의 테이블을 각각 정렬한 후에 병합하는 방식으로 JOIN을 수행합니다. <br>
  이 알고리즘은 정렬이 필요하므로 많은 자원과 시간이 소요될 수 있습니다. 
  그러나 정렬된 데이터를 병합하는 방식이므로, 메모리가 제한적인 경우에도 사용할 수 있습니다.
  <br>
  Hash Join<br>
  Hash Join은 두 개의 테이블에서 해시 함수를 사용하여 매칭되는 레코드를 찾는 방식으로 JOIN을 수행합니다. <br>
  이 알고리즘은 많은 자원을 요구하지만, 빠른 성능을 보장합니다. 
  해시 함수를 사용하기 때문에 레코드의 키 값을 해싱하여 메모리에 저장해야 하므로, 메모리가 부족한 경우에는 문제가 될 수 있습니다.
  <br>
  Merge Join with Indexes<br>
  Merge Join with Indexes는 두 개의 테이블에서 인덱스를 사용하여 JOIN을 수행하는 방식입니다. <br>
  인덱스를 사용하기 때문에 테이블을 스캔하지 않아도 되므로, Nested Loop Join 보다 빠른 성능을 보장할 수 있습니다. 
  그러나 인덱스를 만드는데 시간과 자원이 많이 필요하므로, 인덱스를 미리 만들어 놓는 것이 좋습니다.
  <br> 참고 <br>
  https://velog.io/@jduck1024/%EC%A1%B0%EC%9D%B8-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EB%A6%AC
  </details>

- 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?

  <details>
  입력한 쿼리에서 사용되는 JOIN 알고리즘은 DBMS에 따라 다릅니다. 일반적으로 DBMS는 입력받은 쿼리를 최적화하고 실행 계획을 결정하기 위해 쿼리 옵티마이저(Query Optimizer)를 사용합니다.
  쿼리 옵티마이저는 입력받은 쿼리를 분석하여 어떤 JOIN 알고리즘을 사용할지 결정합니다. 이때, 사용되는 JOIN 알고리즘은 입력받은 쿼리의 조건절, 테이블의 크기, 인덱스의 존재 여부 등 다양한 요인에 따라 결정됩니다.
  일부 DBMS에서는 쿼리 실행 계획을 확인할 수 있는 EXPLAIN 문을 지원합니다. <br>
  EXPLAIN 문을 실행하면 DBMS는 쿼리 실행 계획을 출력하여 어떤 JOIN 알고리즘이 사용되는지 확인할 수 있습니다.
  그러나 EXPLAIN 문을 사용하지 않더라도, DBMS가 최적의 실행 계획을 결정하기 위해 쿼리 옵티마이저를 사용한다는 점은 알고 있어야 합니다. 
  따라서, 쿼리를 작성할 때는 최적화 가능한 쿼리를 작성하여 쿼리 옵티마이저가 최적의 실행 계획을 결정할 수 있도록 해야 합니다.
  </details>

- 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?

  <details>
    네, JOIN 성능도 인덱스의 유무와 종류에 따라 영향을 받습니다.
  JOIN은 테이블 간의 관계를 연결하여 결과를 출력하는 작업입니다. 이때, JOIN을 수행하는 컬럼에 인덱스가 존재하면 인덱스를 이용하여 빠른 검색이 가능합니다. 즉, JOIN 조건에 사용되는 컬럼에 인덱스가 있다면 JOIN을 수행할 때 더 빠르게 처리될 수 있습니다.
  예를 들어, 테이블 A와 B를 JOIN 할 때, A 테이블의 컬럼 x와 B 테이블의 컬럼 y를 JOIN 조건으로 사용한다면, A 테이블의 x 컬럼과 B 테이블의 y 컬럼에 인덱스가 있다면 JOIN 성능이 향상될 수 있습니다.<br>
  하지만, JOIN 조건에 사용되는 컬럼에 인덱스가 존재하지 않는다면, DBMS는 전체 테이블 스캔을 수행하여 JOIN을 수행하게 됩니다. 
  이 경우, 대용량 데이터에서는 처리 시간이 많이 소요될 수 있습니다.
  따라서, JOIN을 수행할 때는 JOIN 조건에 사용되는 컬럼에 적절한 인덱스를 생성하여 JOIN 성능을 최적화하는 것이 중요합니다.
  </details>

## 정리 링크

수민 : https://sustco.tistory.com/42 비밀번호:1234