### 공부 주제(복습 + 추가)

- PCB와 Context Switching
- CPU 스케줄링
- 데드락
- Race Condition
- 세마포어 & 뮤텍스


## 질문
### Context Switching & Threads

- **Context switching 이 무엇인가요?**
  <details>
    CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에 읽어 레지스터에 적재하는 과정<br>
  </details>
    
- **그러면 context switching 은 언제 발생하나요?**
  <details>
    주어진 time slice를 다 사용했거나, IO 작업을 해야하거나, 다른 리소스를 기다려야 하거나<br>
  </details>

- **PCB는 무엇이고 context switching 일 때 어떻게 사용되나요?**
  <details>
    프로세스 메타데이터들을 저장해 놓는 곳, 한 PCB 안에는 한 프로세스의 정보가 담김. Linked list 방식으로 관리<br>
  </details>
    
- **컨텍스트 스위칭의 종류가 있나요?**
  <details>
    스레드 컨텍스트 스위칭, 프로세스 컨텍스트 스위칭<br>
  </details>

- **스레드 컨텍스트 스위칭과 프로세스 컨텍스트 스위칭 중 더 빠른 쪽은?**
  <details>
    프로세스는 하나 이상의 쓰레드를 포함한다. 이 쓰레드들은 고유한 Stack영역의 메모리와 고유한 registers를 할당 받으며 Heap영역의 메모리에서 선언된 데이터는 서로 공유한다.<br>
    동일한 프로세스 속에서 thread context switching이 발생할 경우 processor는 stack영역의 주소와 registers 주소를 포함한 thread의 context 정보만을 변경하면 된다.<br>
    하지만 process context switching이 발생할 경우 processor는 thread의 context뿐만 아니라 process의 context까지 모두 변경해야 한다.<br>
  </details>
    
- **그렇다면 스레드 컨텍스트 스위칭의 과정을 설명해주세요.**
  <details>
    1. 현재 실행 중인 스레드의 상태를 저장합니다.<br>
    - CPU 레지스터의 값(CPU 레지스터에 저장된 프로세스의 상태 값, PC(Program Counter), SP(Stack Pointer), 레지스터 값 등)을 저장합니다.<br>
    - 현재 스레드의 스택과 힙 등의 메모리 공간에서 필요한 상태 정보를 저장합니다.<br>
    2. 스케줄러가 선택한 다음 실행할 스레드의 상태를 복원합니다.<br>
        - 선택된 스레드의 CPU 레지스터 값과 메모리 공간에서 필요한 상태 정보를 복원합니다.<br>
        - 복원된 상태를 기반으로 CPU는 다음 스레드를 실행합니다.<br>
    3. 스케줄러는 선택된 스레드가 이전에 실행되지 않았던 스레드인 경우, 스레드의 초기화 작업을 수행합니다.<br>
        - 초기화 작업에는 스레드 스택의 설정, 스레드 상태의 변경, 스레드 우선순위 설정 등이 포함될 수 있습니다.<br>
    4. 다음 스레드가 실행되면, CPU는 이전 스레드의 상태를 복원할 때 저장했던 정보를 사용하여 이전 스레드에서 실행을 계속합니다.<br>
    TCB 언급 여부
    <br>
  </details>

- **Thread Pool이란?**
  <details>
    보통의 경우 쓰레드를 생성하고 종료하는 작업은 비용이 크므로, 쓰레드 풀은 미리 쓰레드를 생성해 두고 요청이 발생하면 해당 작업을 수행할 쓰레드를 할당합니다. 쓰레드 풀에서 생성된 쓰레드는 일정 시간이       지나면 종료되지 않고 대기 상태로 남아 있습니다.
    <br>
  </details>
    
- **Thread Pool의 장점과 주의할 점?**
  <details>
    <장점><br>
    1. 쓰레드 생성/종료 비용이 줄어듭니다.<br>
    2. 쓰레드 생성과 동시에 쓰레드가 수행되지 않고 대기 상태로 남아 있으므로, 쓰레드 생성과 수행의 비율이 균형적으로 유지됩니다.<br>
    3. 쓰레드의 생성과 수행을 분리할 수 있으므로, 쓰레드 생성 시간에 구애받지 않고 작업을 수행할 수 있습니다.<br>
    4. 동시에 처리 가능한 쓰레드의 개수를 제한함으로써 과도한 자원 소비를 방지할 수 있습니다.<br>
    5. 쓰레드 풀 내의 쓰레드는 동일한 작업을 수행하기 때문에 실행 시간이 일정해집니다.<br>
    <주의점><br>
    1. 쓰레드의 개수를 적절히 설정해야 합니다. 쓰레드의 개수가 너무 적으면 작업 처리 속도가 늦어질 수 있고, 너무 많으면 오히려 성능이 저하될 수 있습니다.<br>
    2. 너무 많은 쓰레드를 생성하면 컨텍스트 스위칭 오버헤드가 발생할 수 있습니다.<br>
    3. 작업 처리 시간이 긴 경우, 쓰레드 풀 내의 쓰레드들이 모두 일시적으로 사용 중일 수 있어 다른 작업 처리가 지연될 수 있습니다.<br>
    <br>
  </details>

- **Thread Safe하다는 건 무슨 뜻인가요?**
  <details>
    멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다.
    <br>
  </details>
    
- **쓰레드 세이프하다는 것을 어떻게 알아내나요?**
  <details>
    1. 전역 변수나 힙, 파일과 같이 여러 스레드가 동시에 접근할 수 있는 자원을 사용하는가?<br>
    2. 핸들과 포인터를 통한 데이터의 간접 접근이 가능한가?<br>
    3. 부수 효과를 가져오는 코드가 있는가?<br><br>
    - Mutual Exclusion (상호 배제)<br>
    - Atomic Operation (원자 연산)<br>
    - Thread-Local Storage (쓰레드 지역 저장소)<br>
    - Re-Entrancy (재진입성)<br>
    <br>
  </details>

- **멀티 스레드 방식의 단점은?**
  <details>
    - 동기화 문제 - 공유자원에 대한 동기화 처리<br>
    - 오버헤드 - 여러개의 스레드를 생성하고 관리하기 위한 추가적인 오버헤드 발생 (컨택스트 스위칭)<br>
    - Race condition 발생 가능성<br>
    - 디버깅과 테스팅의 어려움<br>
    <br>
  </details>

### PCB와 Context Switching

- **스레드 컨텍스트 스위칭과 프로세스 컨텍스트 스위칭의 공통점과 차이점은?**

  <details>
  공통점<br>
  - 커널 모드에서 실행<br>
  - CPU의 레지스터 상태를 교체<br>
  <br>
  차이점<br>
  - 프로세스 컨텍스트 스위칭은 가상(virtual) 메모리 주소 관련 처리를 추가로 수행<br>
  - MMU(메모리 메니지먼트 유닛)도 새로운 프로세스의 주소체계를 바라볼수 있도록 수정<br>
  - TLB라고 불리는 가상 메모리의 주소와 실제 물리적인 메모리의 주소에 맵핑 정보를 들고 있는 캐시역할을 하는 TLB도 비워줘야한다.<br></details>

- **캐시오염이란?([Context switching이 미치는 간접적인 영향에 대해 알고 있는가?](/4주차.md)에 대한 추가 질문)** 

  <details>
  컴퓨터 시스템에서 캐시 메모리에 잘못된 데이터가 저장되어 있는 상태로 컨텍스트 스위칭이 일어난 직후 캐시를 조회할 경우 이전 프로세스or스레드 관련 캐시가 저장되어 있기 때문이다.
  즉 컨텍스트 스위칭이란 스레드나 프로세스가 바뀌는 것이기에 캐시에 저장되어 있는 프로세스나 스레드의 정보와 일치하지 않을 경우가 많아진다.
  </details>

- **프로세스 컨텍스트 스위칭, 스레드 컨텍스트 스위칭 중 캐시오염확률이 더 낮은것은?**

  <details>
  스레드컨텍스트 스위칭.<br> 스레드 컨텍스트 스위칭은 같은 프로세스에서만 발생하고 공유데이터가 없는 독립적인 프로세스보다 데이터 교환 빈도가 적다. <br>
  그러나, 스레드 컨텍스트 스위칭에서도 스레드 간에 공유되는 데이터를 접근하는 패턴이 다르면 캐시오염이 일어난다. 
  </details>

- **캐시오염에 대해 말씀해주셨는데, DNS 캐시오염에 대해서 알고 있나요? 설명해주세요.**

  <details>
  도메인 네임 서버(DNS)의 Resolver 캐시에 변조된 주소를 주입하여 사용자가 웹페이지 접속 시 공격자가 의도한 페이지로 접속을 유도하는 주소 변조 공격 
  <br><br>
  이것을 막기 위한 방법은?<br>
  DNS서버 캐시 크기 조정, DNS 서버 업데이트, 캐시 덤프 제한 등
  </details>

- **컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?**

  <details>
  PCB정보가 커널스택에 저장된다.
  (해당 질문 레퍼지토리분 작성자분이 말씀하시길 그냥 PCB정보가 저장되는 걸 알라는 질문이셨다고 하십니다)
  </details>

------

### CPU 스케줄링

- **단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.**

  <details>
  단기 스케쥴러는 어떤 프로세스를 실행시킬지, <br>
  중기 스케쥴러는 메모리 공간이 부족한 경우 어떤 프로세스를 Swap Out(프로세스를 내리는 것) 할건지, <br>
      장기 스케쥴러는 어떤 프로세스를 Ready Queue에 보낼지 결정한다.<br></details>

- **현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?**

  <details>
  아니요 현재는 단기 스케쥴러만 사용하고 있으며, 중기와 장기는 가상메모리로 인해 없어진 상태입니다. <br>
  왜?) 가상메모리로 인해 Ready Queue에 올라갈 프로세스의 수를 조절하지 않아도 되기 때문에
  </details>

- **비선점, 선점 중에 현대에 자주 쓰이는 스케쥴링과 이유는?**

  <details>
  선점스케쥴링. 특히, 대규모 시스템에서는 다양한 프로세스 및 스레드가 동시에 실행되는 경우가 많기 때문에, 선점 스케쥴링 방식이 필요합니다. <br>
  또한, 실시간 시스템에서는 정확한 타이밍이 중요하므로, 선점 스케쥴링이 필요합니다. <br>
  선점 스케쥴링은 CPU를 강제로 빼앗아 사용할 수 있기 때문에, 비선점 스케쥴링에 비해 오버헤드가 적습니다.<br>
  </details>

- **RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.**

  <details>
  time quantum 이 너무 짧으면 Context Switching이 자주 발생해 Overhead가 증가한다.<br>
  time quantum 이 너무 길면 response time 이 길어진다.
  </details>

  

------

### 데드락


- 


- 

------

### Race Condition & DeadLock

- **RaceCondition이 무엇인가요?**
  <details>두 개 이상의 프로세스가 공통 자원을 병렬적으로 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근 순서에 따라 결과값이 달라지는 상황<br></details>
- **RaceCondition은 언제 발생하나요?**

  <details>
    1. 커널 작업을 수행하는 중 인터럽트 발생<br>
    2. 프로세스가 시스템 콜을 하여 커널모드로 진입 할 때 컨텍스트 스위칭이 발생할 때<br>
    3. 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근 할 때<br></details>
- **RaceCondition이 발생하는 것을 막기 위해 Mutual exclusion을 쓸 때 어떤 문제가 발생하나요?**

  <details>
  1. **Mutual exclusion**<br>
    두개 이상의 프로세스가 공유자원에 동시에 접근하는 것을 막는 것.<br>
  2. Mutual Exclusion으로 인한 DeadLock 발생.<br>
  3. Starvation 발생.<br>
  </details>


- **RaceCondition을 해결하는 방법에는 어떤 방법들이 있나요?**
  <details>
  - Mutex<br>
  - Semaphor<br>
  </details>
- **세마포어 방식과 뮤텍스 방법의 차이점은 무엇인가요?**
  <details>뮤텍스(Mutex)는 상호 배제 기법 중 하나로, 공유 자원에 대한 동시 접근을 방지하기 위해 사용됩니다. 뮤텍스는 한 번에 하나의 스레드만이 공유 자원에 접근할 수 있도록 잠금(lock)을 걸어서 사용합니다. 뮤텍스를 소유하고 있는 스레드만이 뮤텍스를 해제할 수 있습니다. 뮤텍스는 잠금을 얻을 수 없는 스레드가 대기할 수 있도록 효율적으로 구현되어 있습니다.<br><br>
  세마포어(Semaphore)는 카운팅 세마포어와 이진 세마포어 두 가지 종류가 있습니다. 카운팅 세마포어는 지정된 값 이상의 스레드가 접근할 수 없도록 제한하는 방식입니다. 이진 세마포어는 뮤텍스와 비슷한 역할을 하지만, 뮤텍스가 상호 배제 기법에 중점을 두는 반면 세마포어는 자원의 개수를 나타내는 카운터를 가지고, 그 카운터 값이 0인 경우 스레드를 대기시키는 방식입니다.<br>
</details>

- **세마포어 방식의 과정은?**
  <details>
  1. 세마포어 초기화: 공유 자원을 사용하기 전에 세마포어 값을 초기화합니다.<br>
  2. 세마포어 값 확인: 공유 자원에 접근하려는 프로세스나 쓰레드는 세마포어 값을 확인합니다.<br>
  3. 세마포어 값 감소: 공유 자원에 접근하는 프로세스나 쓰레드는 세마포어 값을 1 감소시킵니다.<br>
  4. 공유 자원 접근: 세마포어 값이 0인 경우, 공유 자원에 접근할 수 있습니다. 이때, 다른 프로세스나 쓰레드가 이미 공유 자원을 점유하고 있다면, 세마포어 값이 0이 될 때까지 대기합니다.<br>
  5. 공유 자원 사용 완료: 공유 자원 사용이 끝난 후, 세마포어 값을 1 증가시킵니다.<br>
  6. 세마포어 값 반환: 공유 자원 사용이 끝난 후, 세마포어 값을 반환합니다<br>
  <br>
  </details>
  
- **공유된 자원의 문제로 똑같이 Deadlock이 있는데 RaceCondition은 무슨 차이가 있나요?**
  <details>자원을 할당 받고 성공적으로 프로세스를 실행시켰는가<br></details>
  
- **대표적인 사례로 식사하는 철학자 문제가 있는데, 과정과 해결법을 설명해주세요**
  <details>
  <과정><br>
  1. 일정 시간 생각을 한다.<br>
  2. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.<br>
  3. 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.<br>
  4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.<br>
  5. 오른쪽 포크를 내려놓는다.<br>
  6. 왼쪽 포크를 내려놓는다.<br>
  7. 다시 1번으로 돌아간다.<br>
  <해결법><br>
  1. 홀수 짝수를 매겨서 홀수면 왼쪽부터, 짝수면 오른쪽부터 포크를 잡는다.<br>
  2. 타임아웃 설정<br>
  3. 철학자 상태 구분<br>
  <br>
  </details>
    
    


------

### 세마포어 & 뮤텍스


- **이진 세마포어와 뮤텍스의 차이**

  <details>
  뮤텍스와 이진 세마포어의 핵심 차이는 뮤텍스의 경우 lock을 설정한(값을 0으로 설정한) 프로세스만이 lock을 해제할 수 있다. <br>
  반면, 이진 세마포어의 경우 lock을 설정한 프로세스와 해제하는 프로세스가 서로 다를 수 있다.
  <br>
  따라서, 뮤텍스는 상호 배제 기능만을 제공하며, 이진 세마포어는 상호 배제 외에도 프로세스 간의 통신 기능을 제공하기 때문에, <br>
  상황에 따라 둘 중 적절한 동기화 메커니즘을 선택하여 사용해야 합니다.<br></details>

- **어떻게 이진 세마포어의 경우 lock을 설정한 프로세스와 해제하는 프로세스가 서로 다를 수 있을까?**(꼬리질문)

  <details>
  이진 세마포어의 경우, 값이 0인 경우 해당 자원에 대한 락이 설정되어 있는 상태이고, 값이 1인 경우 자원에 대한 락이 해제된 상태입니다. <br>
  따라서 락을 설정하고 해제하는 것은 단순히 값의 증감으로 이루어집니다.<br>
  이진 세마포어는 뮤텍스와 달리 lock과 unlock이라는 명령어가 없으며, wait()과 signal() 함수를 사용합니다. <br>
  wait() 함수는 세마포어 값을 감소시켜 자원에 대한 락을 설정하는데, 이때 값이 0이 되면 해당 프로세스는 블로킹되어 대기합니다. <br>
  signal() 함수는 세마포어 값을 증가시켜 자원에 대한 락을 해제하는데, 이때 값이 1이 되면 대기하고 있던 프로세스 중 하나를 깨웁니다.<br>
  따라서, 이진 세마포어에서 lock을 설정한 프로세스는 wait() 함수를 호출하여 락을 설정하고, lock을 해제하는 프로세스는 signal() 함수를 호출하여 락을 해제합니다. 이러한 방식으로 락을 설정하고 해제하는 프로세스가 서로 다를 수 있습니다.<br>
  </details>

- **Busy Waiting 바쁜대기 란?**

  <details>
      OS에서는 원하는 자원을 얻기 위해 기다리는 것이 아니라 권한을 얻을 때까지 확인하는 것을 의미한다. <br>
  기다리는 쓰레드가 공유 자원을 사용할수 있는지 없는지 계속해서 무한 루프를 돌면서 조건문을 체크하는 방식<br>
  </details>

  -> [스핀락에 대한 내용](/6주차.md)으로 이어짐

### 정리 링크
