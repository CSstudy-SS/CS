### 공부 주제(복습 + 추가)

- PCB와 Context Switching
- CPU 스케줄링
- 데드락
- Race Condition
- 세마포어 & 뮤텍스


## 질문

### PCB와 Context Switching

- **스레드 컨텍스트 스위칭과 프로세스 컨텍스트 스위칭의 공통점과 차이점은?**

  <details>
  공통점<br>
  - 커널 모드에서 실행<br>
  - CPU의 레지스터 상태를 교체<br>
  <br>
  차이점<br>
  - 프로세스 컨텍스트 스위칭은 가상(virtual) 메모리 주소 관련 처리를 추가로 수행<br>
  - MMU(메모리 메니지먼트 유닛)도 새로운 프로세스의 주소체계를 바라볼수 있도록 수정<br>
  - TLB라고 불리는 가상 메모리의 주소와 실제 물리적인 메모리의 주소에 맵핑 정보를 들고 있는 캐시역할을 하는 TLB도 비워줘야한다.<br></details>

- **캐시오염이란?([Context switching이 미치는 간접적인 영향에 대해 알고 있는가?](/4주차.md)에 대한 추가 질문)** 

  <details>
  컴퓨터 시스템에서 캐시 메모리에 잘못된 데이터가 저장되어 있는 상태로 컨텍스트 스위칭이 일어난 직후 캐시를 조회할 경우 이전 프로세스or스레드 관련 캐시가 저장되어 있기 때문이다.
  즉 컨텍스트 스위칭이란 스레드나 프로세스가 바뀌는 것이기에 캐시에 저장되어 있는 프로세스나 스레드의 정보와 일치하지 않을 경우가 많아진다.
  </details>

- **프로세스 컨텍스트 스위칭, 스레드 컨텍스트 스위칭 중 캐시오염확률이 더 낮은것은?**

  <details>
  스레드컨텍스트 스위칭.<br> 스레드 컨텍스트 스위칭은 같은 프로세스에서만 발생하고 공유데이터가 없는 독립적인 프로세스보다 데이터 교환 빈도가 적다. <br>
  그러나, 스레드 컨텍스트 스위칭에서도 스레드 간에 공유되는 데이터를 접근하는 패턴이 다르면 캐시오염이 일어난다. 
  </details>

- **캐시오염에 대해 말씀해주셨는데, DNS 캐시오염에 대해서 알고 있나요? 설명해주세요.**

  <details>
  도메인 네임 서버(DNS)의 Resolver 캐시에 변조된 주소를 주입하여 사용자가 웹페이지 접속 시 공격자가 의도한 페이지로 접속을 유도하는 주소 변조 공격 
  <br><br>
  이것을 막기 위한 방법은?<br>
  DNS서버 캐시 크기 조정, DNS 서버 업데이트, 캐시 덤프 제한 등
  </details>

- **컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?**

  <details>
  PCB정보가 커널스택에 저장된다.
  (해당 질문 레퍼지토리분 작성자분이 말씀하시길 그냥 PCB정보가 저장되는 걸 알라는 질문이셨다고 하십니다)
  </details>

------

### CPU 스케줄링

- **단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.**

  <details>
  단기 스케쥴러는 어떤 프로세스를 실행시킬지, <br>
  중기 스케쥴러는 메모리 공간이 부족한 경우 어떤 프로세스를 Swap Out(프로세스를 내리는 것) 할건지, <br>
      장기 스케쥴러는 어떤 프로세스를 Ready Queue에 보낼지 결정한다.<br></details>

- **현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?**

  <details>
  아니요 현재는 단기 스케쥴러만 사용하고 있으며, 중기와 장기는 가상메모리로 인해 없어진 상태입니다. <br>
  왜?) 가상메모리로 인해 Ready Queue에 올라갈 프로세스의 수를 조절하지 않아도 되기 때문에
  </details>

- **비선점, 선점 중에 현대에 자주 쓰이는 스케쥴링과 이유는?**

  <details>
  선점스케쥴링. 특히, 대규모 시스템에서는 다양한 프로세스 및 스레드가 동시에 실행되는 경우가 많기 때문에, 선점 스케쥴링 방식이 필요합니다. <br>
  또한, 실시간 시스템에서는 정확한 타이밍이 중요하므로, 선점 스케쥴링이 필요합니다. <br>
  선점 스케쥴링은 CPU를 강제로 빼앗아 사용할 수 있기 때문에, 비선점 스케쥴링에 비해 오버헤드가 적습니다.<br>
  </details>

- **RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.**

  <details>
  time quantum 이 너무 짧으면 Context Switching이 자주 발생해 Overhead가 증가한다.<br>
  time quantum 이 너무 길면 response time 이 길어진다.
  </details>

  

------

### 데드락


- 


- 

------

### Race Condition


- 




------

### 세마포어 & 뮤텍스


- **이진 세마포어와 뮤텍스의 차이**

  <details>
  뮤텍스와 이진 세마포어의 핵심 차이는 뮤텍스의 경우 lock을 설정한(값을 0으로 설정한) 프로세스만이 lock을 해제할 수 있다. <br>
  반면, 이진 세마포어의 경우 lock을 설정한 프로세스와 해제하는 프로세스가 서로 다를 수 있다.
  <br>
  따라서, 뮤텍스는 상호 배제 기능만을 제공하며, 이진 세마포어는 상호 배제 외에도 프로세스 간의 통신 기능을 제공하기 때문에, <br>
  상황에 따라 둘 중 적절한 동기화 메커니즘을 선택하여 사용해야 합니다.<br></details>

- **어떻게 이진 세마포어의 경우 lock을 설정한 프로세스와 해제하는 프로세스가 서로 다를 수 있을까?**(꼬리질문)

  <details>
  이진 세마포어의 경우, 값이 0인 경우 해당 자원에 대한 락이 설정되어 있는 상태이고, 값이 1인 경우 자원에 대한 락이 해제된 상태입니다. <br>
  따라서 락을 설정하고 해제하는 것은 단순히 값의 증감으로 이루어집니다.<br>
  이진 세마포어는 뮤텍스와 달리 lock과 unlock이라는 명령어가 없으며, wait()과 signal() 함수를 사용합니다. <br>
  wait() 함수는 세마포어 값을 감소시켜 자원에 대한 락을 설정하는데, 이때 값이 0이 되면 해당 프로세스는 블로킹되어 대기합니다. <br>
  signal() 함수는 세마포어 값을 증가시켜 자원에 대한 락을 해제하는데, 이때 값이 1이 되면 대기하고 있던 프로세스 중 하나를 깨웁니다.<br>
  따라서, 이진 세마포어에서 lock을 설정한 프로세스는 wait() 함수를 호출하여 락을 설정하고, lock을 해제하는 프로세스는 signal() 함수를 호출하여 락을 해제합니다. 이러한 방식으로 락을 설정하고 해제하는 프로세스가 서로 다를 수 있습니다.<br>
  </details>

- **Busy Waiting 바쁜대기 란?**

  <details>
      OS에서는 원하는 자원을 얻기 위해 기다리는 것이 아니라 권한을 얻을 때까지 확인하는 것을 의미한다. <br>
  기다리는 쓰레드가 공유 자원을 사용할수 있는지 없는지 계속해서 무한 루프를 돌면서 조건문을 체크하는 방식<br>
  </details>

  -> [스핀락에 대한 내용](/6주차.md)으로 이어짐

### 정리 링크
