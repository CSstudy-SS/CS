### 공부 주제

- 문자열 클래스
- Garbage Collection
- Promotion & Casting
- 데드락(DeadLock) (복습)
- Race Condition (복습)
- 세마포어(Semaphore) & 뮤텍스(Mutex) (복습)

## 질문

- JDK 1.5 이후에 String객체 관련해서 성능이 향상된 부분은?
    <details>
      
      JDK 1.5 이후에 컴파일 단계에서 String 객체를 사용하더라도 StringBuilder로 컴파일 되도록 변경되었습니다.
      
    </details>

- 그렇다면 1. 한줄로 모두 선언한 경우 2. 여러줄로 선언한 경우 3. 반복문 안에서 선언한 경우 4. String의 concat() 메서드를 사용하여 선언한 경우 이 4가지 중 성능최적화가 필요하지 않은 경우는?

    <details>
      
      1번. 한줄로 선언한 경우는 하나의 String으로 변환된다. 하지만 여러줄 혹은 반복문에서는 
      
      new StringBuilder로 변환되나 결국은 매 연산시 새로운 객체가 생겨나므로 성능저하가 발생하게 됩니다.
  
      또한 concat()의 경우는 StringBuilder로 전환되지 않기에 성능최적화가 필요합니다.

      참고) https://siyoon210.tistory.com/160
  
    </details>

- JVM의 메모리구조에 대해 말하시오.
    <details>

    - Method Area(Class, Static) : 메인 메서드에서 사용하는 클래스와 static 변수가 저장되는 영역
    - Heap : 객체 인스턴스가 저장되는 영역으로 JVM GC에 의해 관리되는 영역
    - StackStack : 메소드 호출 시 스택 프레임이라는 블록으로 쌓으며, 로컬변수, 중간 연산 결과들이 저장되는 여역
    - PC : 쓰레드가 현재 실행할 스택 프레임의 주소를 저장
    - Native Method Stack : Low Level 코드를 실행하는 스택
      
    </details>

- GC의 장점과 단점을 말하시오.
    <details>
      
    - 장점
      - 메모리 누수 방지
      - 해제된 메모리 접근 방지
      - 해제한 메모리를 다시 이중 해제하는 것 방지
        
    - 단점
      - 개발자가 언제 GC가 메모리를 해제하는지 모름
      - 실행중인 애플리케이션이 리소스를 GC 작업에 내줘야 하므로 오버헤드 발생
    
    </details>

- GC알고리즘에 대해 말하고 설명하시오.
    <details>
      Reference Counting : <br>
      해당 객체에 접근할 수 있는 방법의 개수를 세고, 해당 개수가 0이 되면 GC의 대상이 됨. 이 알고리즘은 순환참조의 문제가 발생

      Mark And Sweep(Mark & Compact) : <br>
      root space에서부터 해당 객체에 접근 가능한지를 기준으로 한다.
      루트부터 그래프 순회를 통해 연결된 객체를 찾아내고, 연결이 끊어진 객체를 지우는 방식.
      그 이후에는 Compaction을 통해 분산 되었던 메모리를 정리한다(필수가 아님)

      GC가 Stack의 모든 변수를 스캔하면서 힙에서 참조된 객체들을 마킹(Mark), 마킹되지 않는 객체를 힙에서 제거(Sweep)
  
    </details>

- String 객체가 불변인 이유에 대해 아는대로 설명해주세요
    <details>

    1. 캐싱 기능에 의한 메모리 절약과 속도 향상
        - Java에서 String 객체들은 Heap의 String Pool이라는 공간에 저장되는데, 참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고, Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을 재사용하는 빈도가 높을 수록 상당한 성능향상을 기대할 수 있다.
    2. Thread-safe
        - String객체는 불변이기 때문에 여러 스레드에서 동시에 특정 String 객체를 참조하더라도 안전하다.
    3. 보안 기능
        - 중요한 데이터를 문자열로 다루는 경우, 강제로 해당 참조에 대한 문자열 값을 바꾸는 것이 불가능하기 때문에 보안에 유리하다.
    </details>

- String, StringBuffer, StringBuilder 클래스의 각각의 특징에 대해 설명하세요

    <details>
      
    ### String

    - new 연산을 통해 생성된 인스턴스의 메모리 공간은 변하지 않음 (Immutable)
    - Garbage Collector로 제거되어야 함.
    - 문자열 연산시 새로 객체를 만드는 Overhead 발생
    - 객체가 불변하므로, Multithread에서 동기화를 신경 쓸 필요가 없음. (조회 연산에 매우 큰 장점)
    
    ### StringBuffer, StringBuilder
    
    - 공통점
        - new 연산으로 클래스를 한 번만 만듬 (Mutable)
        - 문자열 연산시 새로 객체를 만들지 않고, 크기를 변경시킴
        - StringBuffer와 StringBuilder 클래스의 메서드가 동일함.
    - 차이점
        - StringBuffer는 Thread-Safe함 / StringBuilder는 Thread-safe하지 않음 (불가능)

    </details>


- float a = 0.1 는 오류가 발생하는가?

    <details>
    발생한다.

    float a = 0.1f로 코드를 바꿔야한다. 0.1뒤에 d가 생략되어있다. 자바는 실수의 default value는 double이기 때문이다.

    </details>

- 캐스팅이 필요한 이유는?

    <details>
    
    1. **다형성** : 오버라이딩된 함수를 분리해서 활용할 수 있다.
    2. **상속** : 캐스팅을 통해 범용적인 프로그래밍이 가능하다.
    
    <br>   
     ‘캐스팅을 통해 범용적인 프로그래밍이 가능하다.’ 위의 말을 예시를 들어 설명가능한가?
      
  
        class Animal{
        	
        	public void run() {
        		System.out.println("Animal....");
        	}
        }
        
        class Tiger extends Animal{
        	
        	@Override
        	public void run() {
        		System.out.println("Tiger....");
        	}
        }
        
        class Cat extends Animal{
        	
        	@Override
        	public void run() {
        		System.out.println("Cat....");
        	}
        }
        
        class Rabbit extends Animal{
        	
        	@Override
        	public void run() {
        		System.out.println("Rabbit....");
        	}
        }
        
        public class JavaTest {
        	
        	public static void printAnimals(Animal[] animals) {
        		for(Animal a : animals) {
        			a.run();
        		}
        	}
        	
        //	public static void printTiger(Tiger tiger) {}
        //	public static void printCat(Cat cat) {}
        //	public static void printRabbit(Rabbit rabbit) {}
        	
        	public static void main(String[] args) {
        		Animal tiger = new Tiger();
        		Animal cat = new Cat();
        		Animal rabbit = new Rabbit();
        		
        		Animal[] animals = {tiger, cat, rabbit};
        	
        		printAnimals(animals);
        	}
        	
        }

    </details>

- 다운캐스팅에서 주의해야할 점
    <details>

    다운 캐스팅 특성에 대해 주의해야 할 이유는 에디터에서 컴파일 에러가 발생하기 않고 런타임 에러가 발생하는 위험성이 있기 때문
    </details>
