### 공부 주제

- Java 컴파일 과정
- JVM
- 운영체제란(복습)
- 프로세스 vs 스레드(복습)
- 프로세스 주소 공간(복습)

## 질문

- JVM의 목적은?
    <details>
      
    - 자바 프로그램이 어느 기기나 운영체제 상에서도 실행될 수 있도록 하는 것
    - 프로그램 메모리를 관리하고 최적화하는 것
      
    </details>

- JVM 의 구성요소는?

    <details>

    - 클래스로더(Class Loader)
    - 실행엔진(Execution Engine)
    - 가비지컬렉터(Garbage Collector)
    - 런타임데이터영역(runtime data area)
      
   
    </details>


- 클래스 로더를 크게 세가지 계층으로 나누는데, 이에 대해 말해주세요

    <details>
      
    - 부트스트랩 클래스 로더(Bootstrap Class Loader)
      - 최상위 클래스로더로 유일하게 JAVA가 아니라 네이티브 코드로 구현. JVM이 실행될 때 같이 메모리에 올라감. Object 클래스를 비롯하여 JAVA API들을 로드.
      - java8 : jre/lib/rt.jar 및 기타 핵심 라이브러리와 같은 JDK의 내부 클래스를 로드
      - java9이후 : 더 이상 /re.jar이 존재하지 않으며, /lib 내에 모듈화되어 포함됐다. 이제는 정확하게 ClassLoader 내 최상위 클래스들만 로드

    - 익스텐션 클래스 로더(Extension Class Loader)
      - 기본 JAVA API를 제외한 확장 클래스들을 로드한다

    - 시스템 클래스 로더(System Class Loader)
      - 부트스트랩과 익스텐션 클래스로더가 JVM 자체의 구성요소들을 로드한다면, 시스템 클래스로더는 어플리케이션의 클래스들을 로드.
      - 사용자가 지정한 $CLASSPATH내의 클래스들을 로드.

    </details>

- 클래스로더의 위임모델에 대해 설명하시오

    <details>
    위임모델은 클래스로더들 사이에서 클래스를 찾는 순서를 정의하며, 부모 클래스로더에게 위임한다. <br><br>
    최상위 클래스로더까지 위임된 후 해당 클래스가 존재하지 않을 경우 하위 클래스로더에게 요청을 넘긴다.<br>
    (중간에 해당 클래스를 찾으면 거기서 끝내는 JVM도 있고, 찾아도 최상위 클래스로더까지 올라가서 찾는 JVM도 존재)

    </details>

- 클래스로더의 클래스 로드 처리 순서

    <details>
    
    1. 첫번째로 클래스로더 캐시를 확인.<br>
    2. 두번째로 부모 클래스로더.<br>
    3. 마지막으로 자기 자신(self class loader)이 클래스를 탐지한다.
       
    </details>

- 클래스로더의 클래스 동적 로딩 방식 2가지에 대해 말하시오.
    <details>
    
    - 로드타임 동적 로딩 - 하나의 클래스를 로딩하는 과정에서 동적으로 다른 클래스를 로딩
    - 런타임 동적 로딩 - 코드를 실행하는 순간에 클래스를 로딩
    
    </details>

- Execution Engine의 실행 방식 두가지는?
    <details>
      
    - 인터프리터 :바이트 코드 명령어를 하나씩 읽어서 해석하고 실행합니다. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점을 가집니다.
    - JIT 컴파일러 :
      인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식입니다. 
      하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 
      전체적인 실행속도는 인터프리팅 방식보다 빠릅니다. 

      하지만, JIT컴파일러가 컴파일하는 과정은 바이트 코드를 하나씩 인터프리팅 하는 것보다 훨씬 오래걸리기때문에 JIT 컴파일러를 사용하는 JVM은 내부적으로 해당 메서드가 얼마나 자주 호출되고 실행되는지 체크하고, 일정 기준을 넘었을 때만 JIT컴파일러를 통해 네이티브 코드를 생성한다.
    </details>

- 런타임데이터 영역이란? 그리고 해당 구성에 대해 말하시오.

    <details>
    
    - JVM이 운영체제 위에서 실행될 때, 할당 받는 메모리영역.
    - PC레지스터, JVM 스택, 네이티브 메소드 스택/ 힙, 메소드, 런타임 상수풀

    </details>


- 런타임데이터 영역에서 스레드마다 생성되는 공간과 모든 스레드가 공유하는 공간을 나누시오. 

    <details>

    - 스레드마다 하나씩 생성 : PC레지스터, JVM 스택, 네이티브 메소드 스택
    - 모든 스레드가 공유 : 힙, 메소드, 런타임 상수풀

    </details>

- JVM 메모리중 GC에 의해 관리되는 영역은?

    <details>
      
    - 힙

    </details>



### 정리 링크
- 박세정 : [Java 컴파일 과정과 JVM](https://setorylog.oopy.io/1d204fd1-f1bc-4118-803e-9d0eb6a1f4c1)
