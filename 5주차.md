
### 스터디 주제

*  CPU 스케줄링
*  데드락
*  TCP/IP 흐름제어 & 혼잡제어

## 질문
### CPU Scheduling
1. 다중 프로그래밍의 목적은 무엇인지? 다중프로그래밍을 위해 컴퓨터에서 어떤 일을 하는지?

   <details>
       <summary>답변보기</summary>
   
      *  다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해, 항상 실행 중인 프로세스를 가지게 하기 위한다. (CPU 이용률을 최대화하는 것)
        
      *  프로세스 간 교환함으로써 생산적으로 만들기 위해, CPU 스케줄링을 한다.
   </details>

2. CPU 스케줄러란?

   <details>
       <summary>답변보기</summary>

        CPU가 유휴 상태가 될 때마다, 운영체제는 Ready Queue에 있는 프로세스 중에서 하나를 선택해 실행해야한다. 선택 절차는 CPU 스케줄러에 의해 수행된다.
   
   </details>

3. CPU 스케줄링의 대상은 프로세스일까 스레드일까?
   <details>
       <summary>답변보기</summary>

         커널 모드의 스레드
   
   </details>
   
4. Ready Queue 큐에 어떤 레코드들이 들어 있는지?

   <details>
       <summary>답변보기</summary>

      * 큐에 있는 레코드들은 프로세스 제어 블록
   </details>

5. CPU 스케줄링의 결정은 프로세스의 어떤 상황에서 발생하는가?

   <details>
       <summary>답변보기</summary>
   
      * running > waiting 시점은 보통 I/O 요청이 일어나거나 자식 프로세스가 종료 대기를 할 때 입니다.

      *  running > ready 시점은 인터럽트(Interrupt) 가 발생했을 때 입니다.

      *  waiting > ready 시점은 I/O가 완료되었을 때 입니다.

      *  running > terminate 시점은 프로세스가 완전히 종료되었을 때 입니다.
   </details>

6. 비선점 스케줄링과 선점 스케줄링의 차이를 아는지?
   <details>
       <summary>답변보기</summary>
   
      * 선점 (preemptive) : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우 (처리시간 예측 어려움)

      * 비선점 (nonpreemptive) : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 (처리시간 예측 용이함)
   </details>



7. 스케줄러 디스패치가 무엇인지 아는지?

   <details>
       <summary>답변보기</summary>

        준비 상태에 있는 프로세스 중 하나를 선택하여 실행 시키는 것
   
   </details>


8. 여러 CPU 스케줄링 알고리즘 사이에서 하나를 선택하기 위한 CPU 스케줄링 비교 기준이 있다면 어떤 것이 있을까요?

    <detail>
       <summary>답변보기</summary>
        
        1. CPU 이용률
        
        2. 처리량
        
        3. 총처리 시간
        
        4. 대기 시간
        
        5. 응답 시간
        
        CPU 이용률과 처리량을 최대화 하고, 총처리 시간, 대기 시간, 응답 시간을 최소화 하는 알고리즘의 선택이 바람직하다.
    </detail>


9. 비선점형 스케줄링 기법 중에서 아는 거 하나만 말해주세요

    <details>
        <summary>답변보기</summary>

            비선점형 스케줄링에는 크게 **FIFO, SJF, HRN** 세 가지 기법이 존재합니다.
            
            FIFO는 First* In* First* Out(큐와 같음) 으로, 선입선출의 방식입니다. 즉, 먼저 Ready Queue에 들어온 프로세스부터 처리합니다. 대신, 비선점형 스케줄링이므로 아무리 작업시간이 길어도 해당 프로세스를 계속 실행해야합니다.
            
            SJF는 Shortest Job First 의 약자로, 평균 대기 시간을 최소화하기 위해 CPU 점유 시간이 가장 짧은 프로세스부터 CPU를 먼저 할당하는 방식입니다. 단점은 실행시간이 긴 프로세스는 짧은 프로세스들에게 밀려 무한히 대기해야 할 수 있습니다.
            
            HRN은 Highest Response* Ratio Next 의 약자로, SJF 기법을 보완하고자 대기시간과 실행시간을 이용하여 우선순위를 계산하고, 이러한 우선순위에 맞게 프로세스를 실행하는 기법입니다. 장점은 무한히 대기해야 하는 프로세스의 비율을 낮출 수 있습니다.
    </details>

3. 선점형 스케줄링 기법 중에서 아는 거 하나만 말해주세요
   <details>
       <summary>답변보기</summary>

    먼저, SRT는 Shortest Remaining Time 의 약자로, CPU 점유시간이 가장 낮은 프로세스에 먼저 CPU를 할당하는 기법입니다. 단, 선점형 스케줄링이므로 중요한 프로세스가 있거나 남은 실행 프로세스의 실행 시간이 짧은 경우 현재 실행중인 프로세스를 중단하고 해당 프로세스로 옮겨 실행합니다.
   
    다음으로, RR(Round Robin) 기법은 프로세스들 사이에 우선순위를 두지 않고 순서대로 일정 시간 단위만큼 할당하는 기법입니다. 문맥 교환의 오버헤드가 큽니다.
   
    마지막으로, MLQ는 Multi* Level Queue의 약자로, 프로세스들을 특정 우선순위 그룹으로 분류한 후 각각의 다른 Ready Queue를 사용하는 기법입니다. 각각의 Ready Queue 내부는 RR 기법을 사용하고, 하위 Ready Queue의 프로세스를 실행하고 있더라도 상위 Ready Queue에 프로세스가 들어오면 상위 프로세스에 CPU를 할당합니다.
   </details>

3. 선점 우선순위 스케줄링과 비선점 우선순위 스케줄링의 차이
   <details>
       <summary>답변보기</summary>


      *  선점 우선순위 스케줄링
         *  새로 도착한 프로세스의 우선순위가 현재 실행중인 프로세스의 우선순위보다 높으면 프로세서(CPU) 획득
      * 비선점 우선순위 스케줄링
         *  실행중인 것과 무관하게 우선순위가 높다면 큐의 제일 앞에 넣어준다.
   </details>

3. 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스가 계속 들어오면 영원히 스케줄러에 선택받지 못하게 된다. 즉 기아 상태(Starvation)가 된다. 기아상태를 해결할 방법을 알고 있는가?
   <details>
       <summary>답변보기</summary>

         “에이징”이라는 기법을 이용하여 오래 대기하는 프로세스가 우선순위를 점진적으로 증가시켜주는 방법을 이용한다.
   
   </details>

### DeadLock

1. 교착상태(DeadLock)가 무엇인가요?
   <details>
       <summary>답변보기</summary>

    *  프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말한다.

    *  시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생하는 문제
   </details>


3. 데드락이 발생하는 조건에 대해 말해주세요 (4가지)
   <details>
       <summary>답변보기</summary>
    교착상태의 4가지 조건
   
    *  상호배제 : 프로세스들이 필요로 하는 자원에 대해 배타적 통제권을 요구함

    *  점유대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원 기다림

    *  비선점 : 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없음

    *  순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있음
   
    그렇다면 데드락을 발생시키지 않을 예방법은 ?
        
        이 4가지 조건 중 하나라도 만족하지 않으면 교착상태는 발생하지 않음
        
        (순환대기는 점유대기와 비선점을 모두 만족해야만 성립합. 따라서 4가지가 서로 독립적이진 않음)
   </details>


3. 교착상태 해결 방법 4가지
   <details>
       <summary>답변보기</summary>

    *  예방

    *  회피

    *  회복 (무시?)

    *  탐지
   </details>


3. 교착 상태의 회피 기법은 “자원을 할당한 후에도 시스템이 항상 안정 상태에 있을 수 있도록 할당을 허용하는 특징을 가진다.” 
모든 고객의 요구가 충족되도록 현금을 할당하는 데에서 유래한 “은행원 알고리즘”에 대해 알고있다면 아는 대로 말해주세요
   <details>
       <summary>답변보기</summary>

    **프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는 지 사전에 검사하여, 교착 상태 회피**
   
    *  사전에 검사한다, 시뮬레이션 한다가 포인트
   
    미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 안정상태에 들 수 있는지 여부
   
   </details>

3. 은행원 알고리즘이 말하는 “안정상태”가 무엇일까요?
   <details>
       <summary>답변보기</summary>

         시스템의 프로세스들이 요청하는 모든 자원을 데드락을 발생시키지 않으면서도 차례로 모두 할당해주는 것
   
    
   
   </details>

### TCP/IP 흐름제어 & 혼잡제어

1. IP란 무엇인지? IP의 특징과 함께 말해주세요
   <details>
       <summary>답변보기</summary>

      *  IP는 인터넷 환경의 통신 규약
      *  패킷이라는 통신 단위로 데이터를 전달하며, 지정한 IP주소로 데이터를 전송
      *  패킷을 받는 대상이 존재하는지, 패킷이 올바르게 전달됐는지 확인하지 않아서 “비연결성, 비신뢰성”이라는 특징 존재
   
   </details>


1. TCP의 역할에 대해 말해주세요
   <details>
       <summary>답변보기</summary>

      *  오류 없는 데이터 전송
      *  순서에 맞는 전달 (데이터에 언제나 보낸 순서대로 도착한다.)
      *  조각나지 않는 데이터 스트림 (언제든 어떤 크기로든 보낼 수 있다.)
   
   
   </details>

1. 올바른 통신을 하기 위해 TCP가 갖는 기능은?
   <details>
       <summary>답변보기</summary>

      1. 패킷이 빠졌을경우, 재전송을 요청하는 기능
      2. 패킷에 일련번호를 줌으로써, 서로 다르게 도착될지도 모르는 패킷의 순서를 재조합하는 기능
         
   
   </details>

1. TCP는 패킷을 어떻게 추적하고 관리할까?
   <details>
       <summary>답변보기</summary>

         데이터는 패킷 단위로 쪼개져 같은 목적지로 전송된다.
       
         **따라서 패킷에 각각 번호를 부여하여 패킷의 분실 확인 처리를 하기 위해 목적지에서 패킷을 재조립한다.**
       
         이런 방식으로 패킷을 추적하며, 나누어 보내진 데이터를 목적지에서 받고 재조립할 수 있다.
   </details>

1. TCP/IP 계층에 대해서 알고 있는지?
   <details>
       <summary>답변보기</summary>
   
         패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP를 합쳐서 부르는 말
   
      * TCP와 IP의 차이는?
         *  IP주소 체계를 따른다. (네트워크 계층 layer3)
         *  TCP 특성을 활용해 송수신자의 논리적 연결을 생성하고, 신뢰성을 유지할 수 있도록 하겠다.(전송계층 layer4)
      *  정확히 말하자면 TCP가 올바른 통신을 하도록 도와주는 기능을 가지고 있으며, IP는 이러한 기능없이 오로지 TCP 패킷을 전송하는 일만을 한다.
   
   
   </details>

1. TCP/IP 가 계층화 된 이유?(OSI 7계층과 동일)
   <details>
       <summary>답변보기</summary>

      *  변경에 자유롭다. 만약 인터넷이 하나의 프로토콜로 되어 있으면, 어디선가 사양이 변경되었을 때 전체를 바꿔야 하지만, 계층화되어 있으면 사양이 변경된 계층만 바꾸면 된다

      *  설계를 편하게 할 수 있다. 애플리케이션 층에서 애플리케이션은 자기 자신이 담당하는 부분만 고려하면되고, 상대가 어디있는지, 어떤 루트로 전달하는지, 전달한 메시지가 확실하게 전달되고 있는지와 같은 사실은 고려하지 않아도 된다.
   
   </details>

1. 앞서 공부했던 OSI 7계층과 TCP/IP 주소의 차이점은 무엇일까? 계층 수 빼고
   <details>
       <summary>답변보기</summary>

      *  OSI는 역할 기반, TCP/IP는 프로토콜 기반
      *  OSI는 통신 전반에 대한 표준
      *  TCP/IP는 데이터 전송기술 특화
   </details>

1. 웹 브라우저에 www.google.com을 입력한 경우 TCP/IP 통신의 흐름을 설명하라
   <details>
       <summary>답변보기</summary>

      (준엽님 4주차 정리본이 더 정확해서 첨부)

      1. 시작 포트 번호와 도착 포트 번호 (80)는 알지만, 목적지의 IP주소를 모른다.
      2. os 에서 DNS 서버로 요청을 보내게 된다. (DNS 서버는 컴퓨터에 등록이 되어 있다.) 53번 포트를 이용해 연결.
      3. 도메인이 담긴 쿼리를 도메인 서버로 보낸다. (DNS 서버로 도메인 출발!)
      4. DNS는 UDP 사용 ⇒ 도메인 이름에 대한 IP주소를 받아옴(IP 주소를 알았으니 IP를 이용하여 MAC 주소를 찾을 차례이다)
      5. MAC 주소를 모른다. ⇒ ARP프로토콜( IP ⇒ MAC) (모든 준비가 완료된 packet 생성 완료)
      6. 패킷이 네트워크로 나갈 준비 완료.
      7. 구글 서버로 라우팅시작
      8. 먼저 3way* hanshaking를 서버(google) 와 진행. 완료 후에 TCP 통신 준비 완료 packet을 전송할 준비 완료
      9. http request 응답 후 response를 client로 전달
      10. 4* way* handshaking (이후 종료)
   
   </details>

1. TCP 의 3way handshake의 취약점을 이용해 서버를 공격하는 방법으로 SYN Flooding이라는 기술이 있다. 해당 DDOS 방법에 대해 아는가?
   <details>
       <summary>답변보기</summary>

         요약
       
         악의적인 공격자가 실제로 존재하지 않는 클라이언트 IP로 응답이 없는 연결을 초기화 하기 전에 또 새로운 연결 즉, 1단계 요청만 무수히 많이 보내어, 백로그 큐를 포화 상태로 만들어 다른 사용자로부터 더이상에 연결 요청을 못받게 하는 기법
       
         기술 내용
       
         클라이언트가 SYN(1번) 패킷만 계속적으로 보내고 ACK(3번) 패킷을 안보내게 되면, 서버는 클라이언트의 연결을 받아들이기 위해 RAM(메모리) 공간을 점점 더 많이 확보 해둔 상태에서 대기한다.

      * BackLog Queue : 서버가 접속자의 연결 요청을 대기할 때, 요청 정보를 저장하는 공간

         > 만약 정상 연결이 되었다면, 백로그 큐 공간에 연결 요청 정보가 삭제되어 공간은 계속 유지된다.
         하지만 중간에 정상적으로 진행되지 않는다면 정보가 계속 백로그 큐에 남아있게 되고 계속적으로 연결요청 대기 Queue가 쌓이면 백로그 큐 공간을 가득 채워 다른 연결요청 정보 저장이 불가능하다.
         > 

         이 공격을 당하게 되면 TCP연결 가능한 자원을 모두 소진하게 되고 외부 사용자는 TCP 연결을 할 수 없게 되는 공격이다.
         
   
   </details>

1. SYN Flooding 문제가 발생한다면 어떤 대응책이 있을 것 같은지? 모른다면 생각해봐도 된다!
   <details>
       <summary>답변보기</summary>

      1. 백로그 큐의 크기를 늘린다. (완벽한 방어방법은 아니지만, 임시로 접속 문제 해결 가능)
      2. SYN Cookie를 설정한다.
         
         이 설정을 하게 되면, 클라이언트로부터 ACK를 받을 때까지 Backlog Queue에 요청 정보를 저장하지 않는다
         
         쿠키라는 것을 이용하여, 전체 연결이 설정되기 전 까지는 자원의 할당을 연기하는 방법
         
      3. 방화벽의 동일 클라이언트 IP에 대해 연결요청(SYN) 임계치를 설정한다.
      4. TCP 연결 과정 대기 시간을 줄인다.
   
   
   </details>

1. TCP 패킷이 3 ways handshake를 했는지 안했는지는 어떻게 저장하고 있지?
   <details>
       <summary>답변보기</summary>

      TCP 세그먼트 헤드에 flag 값이 비트로 저장, 이걸로 현재 클라이언트 서버와 연결했는지 확인합니다
   
   </details>

1. TCP 패킷 헤더에 왜 Data offset이 존재하지? 없으면 어떻게 되는데?
   <details>
       <summary>답변보기</summary>

      *  **헤더가 아닌 데이터가 시작되는 위치. 옵션 필드의 길이가 고정이 아니라 넣어줘야하는 필드이다.**
         *  32비트 워드로 TCP 헤더의 크기를 지정하는 "데이터 오프셋" 필드를 포함
         *  데이터 오프셋 필드를 사용하면 패킷 수신기가 헤더의 크기와 페이로드 **데이터의 시작 위치를 쉽게 결정 가능**
      *  Data Offset 필드는 TCP 헤더에 포함되며 헤더의 크기를 나타내는 데 사용
      *  **헤더에 데이터 오프셋 필드가 없으면 수신기가 헤더의 크기를 결정할 수 없으므로 패킷을 제대로 처리할 수 없습니다**
      *  Data Offset 필드는 TCP 헤더의 중요한 부분이며 TCP 프로토콜의 적절한 기능을 위해 필수적
   
   </details>


1. TCP의 흐름제어는 어떤 상황에서 발생하는 지 아시나요?
   <details>
       <summary>답변보기</summary>

      *  수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생긴다.
      *  수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실 될 수 있으며, 만약 손실 된다면 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번히 발생한다.
      *  이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신측에 따라 조절해야한다.
   
   </details>

1. 그렇다면 해결 방법으로 어떤 기법들이 있는 지 아시나요? (아는 것만 말해주세요)
   <details>
       <summary>답변보기</summary>

      *  Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
      *  Sliding Window (Go Back N ARQ)
         *  수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법
   
   </details>
1. Sliding window가 뭔지 아는지?
   <details>
       <summary>답변보기</summary>

      수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법

      먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송

      Stop and Wait의 비효율성을 개선

      *  window : TCP 헤더 패킷에 포함된 한번에 보낼 수 있는 최대 버퍼수, 이 버퍼수에 따라 한번에 보내는 양이 결정
   
   </details>

1. TCP의 혼잡제어는 어떤 상황에서 발생하는지?
   <details>
       <summary>답변보기</summary>

   *  송신측의 데이터 전달과 네트워크 데이터 처리 속도를 해결하기 위한 기법이다.
   *  한 라우터에게 데이터가 몰려 모든 데이터를 처리할 수 없는 경우, 호스트들은 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실이 발생한다.
   *  이러한 `네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어`하는 것이 혼잡 제어의 개념이다.
   
   
   </details>
1. 혼잡제어의 기법으로 AIMD 기법이 있는데, 처음에 패킷 하나를 보내는 것으로 시작하여 전송한 패킷이 문제 없이 도착한다면 Window Size를 1씩 증가시키며 전송하는 방법이다. 어떠한 문제점이 존재할까?
   <details>
       <summary>답변보기</summary>

   문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.
   
   </details>
1. TCP의 혼잡제어 기능으로 느린시작(Slow Start)는 무엇인지?
   <details>
       <summary>답변보기</summary>

      TCP 커넥션은 시간이 지나면서 자체적으로 튜닝되어, 처음에는 커넥션의 최대 속도를 제한하고, 데이터가 성공적으로 전송됨에 따라 속도제한을 높여간다.

      → 이는 인터넷의 급작스러운 부하와 혼잡을 방지하는 데 사용한다.
   
   
   </details>






## 각자 정리한 부분

* 박세정 : [5주차 노션 정리(개념 & 질문 준비)](https://evening-november-9ec.notion.site/5-a63da288490d4b34b9553426bb62ed5e) 

* 수민 : https://sustco.tistory.com/36 비번 : 1234 <br>

* 준엽: https://www.notion.so/Week5-CPU-DeadLock-TCP-IP-938d1dd0d36248dfafc61c0b8d9b8a93
